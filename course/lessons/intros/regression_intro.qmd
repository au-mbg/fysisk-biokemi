## Python: Introduction to curve fitting

```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
```

Curve fitting is a fundamental skill in biochemistry and biophysics for analyzing experimental data. We use curve fitting to determine parameters in mathematical models that describe biological processes like enzyme kinetics, binding affinity, and reaction rates.

The basic idea is to find the parameters of a mathematical function that best describes our experimental data.

#### (a) Understanding the problem
Real biochemical data is often requires complex fitting functions. Therefore, we will start out with a simpler data that follows a linear relationship. The data below represents a theoretical experiment where we measure some output $y$ at different input values $x$:

```{python}
## This makes two arrays (columns) ##
## One with the x coordinates ##
## One with the y coordinates ##
x_data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y_data = np.array([2.1, 4.2, 6.0, 7.8, 10.1, 12.2, 13.9, 16.1, 18.0, 20.2])
```
The functions above simply make two arrays - i.e. columns of data - containing the number. You can view the content of these colmns by with `print(x_data)` or `print(y_data)`.
```{python}
#| fig-align: center
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Plot the data as a scatter plot ##
## Recall that you can do this with: ax.plot(x_data, y_data, 'o')
...
```

```{python}
#| fig-align: center
#| solution: true
# Plot the data
fig, ax = plt.subplots()

## Your task: Plot the data as a scatter plot! ##
## Recall that you can do this with: ax.plot(x_data, y_data, 'o')
ax.plot(x_data, y_data, 'o')

## EXTRAS - You do not need to read or understand ##
## Adding customization ##
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('Experimental data points');
```

Looking at this data, we can see it roughly follows a straight line. Let's assume our model is:

$$y = ax + b$$

where $a$ and $b$ are parameters we want to determine from the data.

#### (b) Defining a fitting function

To use `scipy.optimize.curve_fit`, we need to define a function where:

- The **first** argument is the independent variable (x)  
- The remaining arguments are the parameters to be fitted

Define a linear function for fitting:

```{python}
#| exercise: true
#| eval: false
def linear_function(x, a, b):
    ## Your task: Calculate the linear function ##
    result = ...
    return result
```

```{python}
#| solution: true
def linear_function(x, a, b):
    ## Your task: Calculate the linear function ##
    result = a * x + b
    return result
```

Always a good idea to check that your function works as expected 

As a test we are adding 1 in the place of x, 2 in the place of a and 0 in the place of 
b. In other words: $1 \cdot 2 + 0 = 2$

```{python}
#| eval: false
linear_function(1, 2, 0) # Should give 2
```

When in doubt it is a good idea to do sanity checks like this.

#### (c) Your first curve fit

Now we can use `curve_fit` to find the best parameters. The basic syntax is:

```python
fitted_parameters, trash = curve_fit(function, x_data, y_data, p0=initial_guess)
```

Where:

- `function`: The function we defined above
- `x_data`, `y_data`: Our experimental data
- `p0`: Initial guess for parameters (optional but recommended)
- `fitted_parameters`: The optimized parameters (what we want!)
- `trash`: Don't worry about this. 

Finish the cell below to perform the curve fit by adding the three missing arguments to 
the call to `curve_fit`.

```{python}
#| exercise: true
#| eval: false
# Initial guess: a=2, b=0
initial_guess = [2, 0]

## Your task: Perform the fit ##
## You need give the function three arguments ##
## The function: linear_function ##
## The x-data: x_data
## The y-data: y_data
fitted_parameters, trash = curve_fit(..., ..., ..., p0=initial_guess)

## Extract parameters ## 
a_fit, b_fit = popt

print(fitted_parameters)
print(a_fit)
print(b_fit)
```

```{python}
#| solution: true
# Initial guess: a=2, b=0
initial_guess = [2, 0]

# Perform the fit
fitted_parameters, trash = curve_fit(linear_function, x_data, y_data, p0=initial_guess)

# Extract parameters
a_fit, b_fit = fitted_parameters

print(fitted_parameters)
print(a_fit)
print(b_fit)
```

#### (d) Visualizing the fit

It's crucial to always plot your fit to see how well it describes the data.
To do this we evaluate the function with the fitted parameters and a densely sampled 
independent variable. 

```{python}
#| exercise: true
#| eval: false

## This makes an array with 100 equally spaced points between 0 and 11. ##
x_smooth = np.linspace(0, 11, 100)

## Your task: Calculate linear_function using x_smooth, a_fit and b_fit ##
y_fit = ... 
```

```{python}
#| solution: true
x_smooth = np.linspace(0, 11, 100) # Makes 100 equally spaced points between 0 and 11. 
y_fit = linear_function(x_smooth, a_fit, b_fit) # Call the linear function using x_smooth, a_fit and b_fit
```

Then we can plot it 

```{python}
#| exercise: true
#| eval: false
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the fitted function using x_smooth and y_fit ##
ax.plot(..., ...)

## Plots the experimental data ##
ax.plot(x_data, y_data, 'o')
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the fitted function using x_smooth and y_fit ##
ax.plot(x_smooth, y_fit)

## Plots the experimental data ##
ax.plot(x_data, y_data, 'o')

## EXTRA ##
## You do not need to understand this ##
## Customizes the plot ## 
ax.set_xlabel('x')
ax.set_ylabel('y') 
ax.set_title('Fit')
```

#### (e) Nonlinear fitting: Exponential decay

Many biological processes follow nonlinear relationships. Let's work with exponential decay, which is common in biochemistry (e.g., radioactive decay or unimolecular chemical reactions).

You can load the dataset from the `exp_decay_data.xlsx`-file with the widget below 

```{python}
#| eval: false
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('exp_decay_data')
display(df)
```

Now make a plot of the data

```{python}
#| exercise: true
#| eval: false
# Generate exponential decay data
fig, ax = plt.subplots()

## Your task: Plot the data from the dataframe ´df´. ##
## Recall that your get the time-column as df['time'] ##
## Similarly you get the signal-column  as df['signal'] ##
ax.plot(..., ...)
```

```{python}
#| solution: true
#| fig-align: center

## Your task: Plot the data from the dataframe ´df´. ##
## Recall that your get the time-column as df['time'] ##
## Similarly you get the signal-column  as df['signal'] ##
fig, ax = plt.subplots()
ax.plot(df['time'], df['signal'], 'o')
```

The model we want to fit is:
$$\text{signal} = A e^{-kt}$$

Define the exponential decay function:

```{python}
#| exercise: true
#| eval: false
def exponential_decay(t, A, k):
    ## Your task: Calculate the exponential function ##
    ## Remember that np.exp calculates the exponential function ##
    result = ...
    return result

## This calculates the function for t=1, A=1, k=1 ##
## If you did it correctly you should see 0.3678...
test_result = exponential_decay(1, 1, 1)
print(test_result)
```

```{python}
#| solution: true
def exponential_decay(t, A, k):
    ## Your task: Calculate the exponential function ##
    ## Remember that np.exp calculates the exponential function ##
    result = A * np.exp(-k * t)
    return result

## This calculates the function for t=1, A=1, k=1 ##
## If you did it correctly you should see 0.3678... ##
test_result = exponential_decay(1, 1, 1)
print(test_result)
```

Now fit the exponential function to the data:

```{python}
#| exercise: true
#| eval: false

## We set the initial guess as A=8 and k=1 ##
initial_guess = [8, 1]

## Your task: Make the fit using the exponenital_decay function, and the time and signal data. 
## 
fitted_parameters, trash = curve_fit(..., ..., ..., p0=initial_guess)

# Extract parameters
A_fit, k_fit = fitted_parameters

print(A_fit)
print(k_fit)
```

```{python}
#| solution: true
# Initial guess: A=8, k=1
initial_guess = [8, 1]

# Perform the fit
fitted_parameters, trash = curve_fit(exponential_decay, df['time'], df['signal'], p0=initial_guess)

# Extract parameters
A_fit, k_fit = fitted_parameters

print(A_fit)
print(k_fit)
```

Again we should plot to check that it looks as expected 

```{python}
#| exercise: true
#| eval: false

## This makes 100 linearly spaced points between 0 and 5.
t_smooth = np.linspace(0, 5, 100)

## Your task: Calculate the function using the fitted parameters and t_smooth. ##
signal_fit = ... # Evaluate using the exponential_decay funciton
```

```{python}
#| solution: true

## This makes 100 linearly spaced points between 0 and 5 ##
t_smooth = np.linspace(0, 5, 100)

## Your task: Calculate the function using the fitted parameters and t_smooth ##
signal_fit = exponential_decay(t_smooth, A_fit, k_fit)
```

Now we can plot the fit along with the data. 

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Plot the observations - you can copy this line from the ## 
## previous plot. ##
ax.plot(..., ...)

## Your task: Plot the fit using t_smooth and signal_fit
ax.plot(..., ...)
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the observations - you can copy this line from the ## 
## previous plot. ##
ax.plot(df['time'], df['signal'], 'o')

## Your task: Plot the fit using t_smooth and signal_fit
ax.plot(t_smooth, signal_fit)

## EXTRA - You do not need to understand this ## 
## This adds customization ##
ax.set_xlabel('Time')
ax.set_ylabel('Signal')
ax.set_title('Exponential decay curve fit')
plt.show()
```

---

::: {.callout-tip}

## Key points for successful curve fitting:

1. **Always plot your data first** to understand what kind of function might fit
4. **Always plot the fit** to visually check if it makes sense
5. **Check if parameters are reasonable** based on your biochemical knowledge

:::

::: {.callout-important}

## Summary of `curve_fit`

Fitting refers to finding the parameters that make an assumed functional form best 
'fit' the data. 

In Python we will use the `curve_fit` from the `scipy` package to do so. 
The function looks like this

```python
curve_fit(function, 
            x_data, 
            y_data, 
            p0=[param_1, param_2, ...])
```

The arguments are 

- `function`: A python function where the **first** argument is the independent variable (typically the x coordinate), and other arguments are the parameters of the functions. 
- `x_data`: The observed values of the independent variable (The x coordinates). 
- `y_data`: The observed values of the dependent variable (The y coordinates) .
- `p0`: Initial guesses for the parameters. 

When called `curve_fit` starts by calculating how well the functions fits the data 
with the initial parameters in `p0` and then iteratively improves the fit by 
trying new values for the parameters in an intelligent way. 

The found parameters will generally depend on `p0` and it is therefore necessary 
to provide a good (or good enough) guess for `p0`.

Generally, the best way to learn more about a function is to read it's documentation
and then play around with it. The documentation is in this case on the [SciPy website](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html). You don't need to read it, unless 
you want more details. 

:::

You now have the fundamental skills needed to fit curves to biochemical data! In the exercises, you'll apply these techniques to analyze real experimental data and extract meaningful biological parameters.
