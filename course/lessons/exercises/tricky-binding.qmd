## A tricky protein binding.

```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import curve_fit
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
pd.set_option('display.max_rows', 6)
```

Here, we will analyse the results from an experiment used to quantify affinity of a protein:lignd interaction. The data in `binding_data_sq.xlsx` is in the form of saturation (theta) as a function of the total ligand concentration L_tot. This is the type of data you typically get from e.g. a fluorescence titration experiment. Each measure-ment has been repeated three times.

Load the dataset as usual using the widget below

```{python}
#| exercise: true
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

::: {.callout-tip}
The command `display(df)` shows the dataframe that you've loaded. 
:::

```{python}
#| exercise: true
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('binding_data_sq') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (a) Convert to SI 

Convert the ligand concentration to $\mathrm{M}$ and add it to the dataframe as a new column named `'L_(m)'`.

You can use `display(df)` to check if you have been successful.

```{python}
#| exercise: true
#| eval: false

# Your task: Add a column to the dataframe with the ligand concentration in M.
...
```

```{python}
#| solution: true
df['L_(M)'] = df['L_(uM)'] * 10**(-6)
display(df)
```

#### (b) Plot

Make a scatter plot of the dataset and use the plot to estimate $K_D$.

```{python}
#| fig-align: center
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Make a scatter plot (just points, no lines) of the data.  ##
...
```

```{python}
#| fig-align: center
#| solution: true
fig, ax = plt.subplots()

## Your task: Make a scatter plot (just points, no lines) of the data.  ##
ax.plot(df['L_(M)'], df['theta'], 'o')

## EXTRA: ##
## This adds x and y-axis labels. ##
ax.set_xlabel('L (M)')
ax.set_ylabel(r'$\theta$')
plt.show()
```

Put your estimate of $K_D$ in the cell below 

```{python}
#| exercise: true
#| eval: false
## Your task: Assign your estimate of K_D to the variable below ##
K_D_estimate = ...
```

```{python}
#| solution: true
## Your task: Assign your estimate of K_D to the variable below ##
K_D_estimate = 0.0001
```

#### (c) Fit and analyze.

Fit the data using the simple binding expression

$$
\theta = \frac{[L]}{[L] + K_D}
$$

Start by defining a function, called `simple_binding`, that calculates this expression

```{python}
#| exercise: true
#| eval: false

## Your task: Define the function simple_binding that evaluates the equation ##
## from above. ##
## Hint: It takes two inputs - the first has to be the independent variable. 
def ...
    ...
    ...
```

```{python}
#| solution: true
## Your task: Define the function simple_binding that evaluates the equation ##
## from above. ##
def simple_binding(L, K_D):
    theta = L / (L + K_D)
    return theta
```

Then use that function to fit the data using `curve_fit`

```{python}
#| exercise: true
#| eval: false
## Your task: Set your estimate of K_D as the inital guess.
initial_guess = [...]

## Your task: Use curve_fit to find the fitted value of K_D
fitted_parameters, trash = ...

## This extracts K_D and prints it ##
K_D_fit_simple = fitted_parameters
print(K_D_fit_simple)
```

```{python}
#| solution: true
## Your task: Set your estimate of K_D as the inital guess.
initial_guess = [K_D_estimate]

## Your task: Use curve_fit to find the fitted value of K_D
fitted_parameters, trash = curve_fit(simple_binding, df['L_(M)'], df['theta'], initial_guess)

## This extracts K_D and prints it ##
K_D_fit_simple = fitted_parameters[0]
print(K_D_fit_simple)
```

And evaluate the fit and plot it together with the dataset

```{python}
#| exercise: true
#| eval: false

## Your task: Evaluate simple_binding using L_smooth and the value of K_D from your fit ##
L_smooth = np.linspace(0, 0.0005, 100)
theta_fit_simple = ...

fig, ax = plt.subplots()
## Your task: Plot the fit as line plot and the data as a scatter plot. ##
...
...
```


```{python}
#| solution: true
## Your task: Evaluate simple_binding using L_smooth and the value of K_D from your fit ##
L_smooth = np.linspace(0, 0.0005, 100)
theta_fit_simple = simple_binding(L_smooth, K_D_fit_simple)

fig, ax = plt.subplots()
## Your task: Plot the fit as line plot and the data as a scatter plot. ##
ax.plot(df['L_(M)'], df['theta'], 'o')
ax.plot(L_smooth, theta_fit_simple)

## EXTRA: 
## Labels for the axis.
ax.set_xlabel('L (M)')
ax.set_ylabel(r'$\theta$')
plt.show()
```

Is it a good fit? 

#### (d) Residuals

To get a more quantitative view of the quality of the fit calculate residuals

```{python}
#| exercise: true
#| eval: false

# Your task: Calculate the residuals by evaluating the fit at the measured datapoints
theta_model = ...
residuals_simple = ...
```

```{python}
#| solution: true
theta_model = simple_binding(df['L_(M)'], K_D_fit_simple)
residuals_simple = df['theta'] - theta_model
```

And plot them versus the measured $\mathrm{[L]}$

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Make a plot with residuals on the y-axis and L on the x-axis ##

# This makes a horizontal line through 0
ax.axhline(0, color='black', linestyle='--')
```

```{python}
#| solution: true
#| eval: true
fig, ax = plt.subplots()

## Your task: Make a plot with residuals on the y-axis and L on the x-axis ##
ax.plot(df['L_(M)'], residuals_simple, 'o')

## This makes a horizontal line through 0 ##
ax.axhline(0, color='black', linestyle='--')

## EXTRA
## Adds axis labels. 
ax.set_xlabel('[L] (M)')
ax.set_ylabel('Residual')
```

Are the residuals randomly distributed around zero? 
What does this tell you about the quality of the fit? 

#### (e) Formulate a hypothesis

The protein concentration in the above titrations was 250 uM. Formulate a hypothesis for why the fit fails. 

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer

The assumption made to derive the simple binding model is that the ligand concentration is much 
larger than the protein concentration such that the $[L_\mathrm{free}] \approx [L_\mathrm{total}]$ - 
or in other words that the number of ligand molecules bound to the proteins are not a significant proportion 
of the total number of ligand molecules. With $[P] = 250 \ \mu\textrm{M}$ and ligand concentrations in 
the range of 0 to 500 $\mu\mathrm{M}$ this assumption is not valid.
:::
"""
print(answer)
```

:::::: {.cell .markdown}

::::::

#### (f) Choosing a better model

Next, we will try a fitting model that explicitly considers the concentration of the protein being titrated. 
This is known as the quadratic binding equation

$$
\begin{aligned}
\theta &= \frac{K_D + [P_{tot}] + [L_{tot}]}{2[P_{tot}]} - \sqrt{\left(\frac{K_D + [P_{tot}] + [L_{tot}]}{2[P_{tot}]}\right)^2 - \frac{[L_{tot}]}{[P_{tot}]}} \\
\end{aligned}
$$


The value of $[P_{tot}]$ is $250 \ \mu\mathrm{M}$. 

Start by implementing the expression as a Python function - remember that you need to 
be careful with parentheses with a function like this.

```{python}
#| exercise: true
#| eval: false

def quadratic_binding(L, K_D):
    ## Your task: Set the protein concentration in appropriate units. ##
    P_tot = ... 

    ## Your task: Implement the quadratic binding equation ## 
    ## Be careful with parentheses! ##
    theta = ... 
    return ...

print(f"{quadratic_binding(100, 138.09) = :.3f}") # Should give 0.420
```

```{python}
#| solution: true
def quadratic_binding(L, K_D):    
    ## Your task: Set the protein concentration in appropriate units. ##
    P_tot = 250 * 10**(-6)

    ## Your task: Implement the quadratic binding equation ## 
    ## Be careful with parentheses! ##
    theta = (K_D + P_tot + L) / (2 * P_tot) - np.sqrt(((K_D + P_tot + L) / (2 * P_tot))**2 - L / P_tot)
    return theta

print(f"{quadratic_binding(100, 138.09) = :.3f}") # Should give 0.420
```

And now make a fit using this expression

```{python}
#| exercise: true
#| eval: false

## Your task: Make a fit using the quadratic binding equation. ##
fitted_parameters, trash = ...

## Extratcs and prints K_D ##
K_D_fit_quad = fitted_parameters[0]
print(K_D_fit_quad)
```

```{python}
#| solution: true

## Your task: Make a fit using the quadratic binding equation. ##
fitted_parameters, trash = curve_fit(quadratic_binding, df['L_(M)'], df['theta'])

## Extratcs and prints K_D ##
K_D_fit_quad = fitted_parameters[0]
print(K_D_fit_quad)
```

The cell below makes a figure of the data and the residuals for each fit. You are 
not expected to understand every line of code â€“ the figure is mainly to aid you 
interpretation of the data and show case how you can make beautiful figures from 
you own data later on.
```{python}
#| exercise: true
#| eval: false
theta_fit_quad = quadratic_binding(L_smooth, K_D_fit_quad)
residuals_quad = df['theta'] - quadratic_binding(df['L_(M)'], K_D_fit_quad)

fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Data & Fit
ax = axes[0]
ax.plot(df['L_(M)'], df['theta'], 'o', label='Data')
ax.plot(L_smooth, theta_fit_simple, label='Simple binding', linewidth=3)
ax.plot(L_smooth, theta_fit_quad, label='Quadratic binding', linewidth=3)
ax.set_xlabel('L (M)')
ax.set_ylabel(r'$\theta$')
ax.set_title('Data & Fits')
ax.legend()

# Residuals
ax = axes[1]
ax.plot(df['L_(M)'], residuals_simple, 'o', color='C1', label='Simple binding')
ax.plot(df['L_(M)'], residuals_quad, 'o', color='C2', label='Quadratic binding')
ax.axhline(0, color='black', linestyle='--')
ax.set_title('Residuals')
ax.set_xlabel('L (M)')
ax.legend()

plt.show()
```

```{python}
#| solution: true
#| fig-align: center
theta_fit_quad = quadratic_binding(L_smooth, K_D_fit_quad)
residuals_quad = df['theta'] - quadratic_binding(df['L_(M)'], K_D_fit_quad)

fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Data & Fit
ax = axes[0]
ax.plot(df['L_(M)'], df['theta'], 'o', label='Data')
ax.plot(L_smooth, theta_fit_simple, label='Simple binding', linewidth=3)
ax.plot(L_smooth, theta_fit_quad, label='Quadratic binding', linewidth=3)
ax.set_xlabel('L (M)')
ax.set_ylabel(r'$\theta$')
ax.set_title('Data & Fits')
ax.legend()

# Residuals
ax = axes[1]
ax.plot(df['L_(M)'], residuals_simple, 'o', color='C1', label='Simple binding')
ax.plot(df['L_(M)'], residuals_quad, 'o', color='C2', label='Quadratic binding')
ax.axhline(0, color='black', linestyle='--')
ax.set_title('Residuals')
ax.set_xlabel('L (M)')
ax.legend()

plt.show()
```

#### (g) Analyze 

Consider the following questions: 

- How does the quadratic binding expression fit the data? 
- Whats the difference in how the residuals are distributed? 
- What is the biochemical situation that makes quadratic expression necessary? 

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
- The quadratic binding equation fits the data very well! 
- For the quadratic binding equation the residuals are randomly distributed around zero, whereas for the simple binding model there is a trend as a function of the ligand concentration with negative residuals at low concentrations and positive residuals at higher concentrations. 
- That the protein and ligand concentrations are comparable - making the assumptions that the simple binding model is based on invalid. 

:::
"""
print(answer)
```

:::::: {.cell .markdown}

::::::