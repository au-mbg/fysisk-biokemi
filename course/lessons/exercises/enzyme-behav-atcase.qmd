## Enzymatic behaviour of the enzyme ATCase

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display
```

The enzyme aspartate transcarbamoylase (ATCase) catalyzes the first reaction in the biosynthesis of pyrimidines
such as CTP as shown in the reaction below:

![](https://raw.githubusercontent.com/au-mbg/fysisk-biokemi/refs/heads/main/course/lessons/figures/atcase.png){.lightbox}

ATCase does not obey the Michaelis-Menten kinetics model but instead shows the behaviour recorded in the 
`enzyme-behav-atcase.csv` dataset.

The dataset consists of three columns; the aspartate concentration in mM and the rate of formation of N-carbamyolaspartate
with and without the presence of CTP. 

Load the dataset with the widget below

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('atcase') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (a) Units & Plot

```{python}
#| exercise: true
#| eval: false
## Your task: Add columns with the properties in SI units.
df['[aspartate]_(M)'] = ...
df['rate_(M/s)'] = ...
df['rate_ctp_(M/s)'] = ...
```

```{python}
#| solution: true
## Your task: Add columns with the properties in SI units.
df['[aspartate]_(M)'] = df['[aspartate]_(mM)'] * 10**(-3)
df['rate_(M/s)'] = df['rate_(uM/s)'] * 10**(-6)
df['rate_ctp_(M/s)'] = df['rate_ctp_(uM/s)'] * 10**(-6)
```

Make a plot of the `rate_(M/s)` dataset versus the aspartate concentration. 

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Plot the dataset
...

## Adds legend and labels.
ax.set_xlabel('[Aspartate] (M)')
ax.set_ylabel('Rate of formation (M/s)')
ax.legend()
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the datasets
ax.plot(df['[aspartate]_(M)'], df['rate_(M/s)'], label='No CTP')

ax.set_xlabel('[Aspartate] (M)')
ax.set_ylabel('Rate of formation (M/s)')
ax.legend()
```

#### (b) Kinetic profile

Looking at the curve without CTP, describe the kinetic profile of ATCase and explain what it tells us about the way ATCase works. (You may find inspiration in the material previously covered on protein-ligand interactions)

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer

The midpoint has a steep increase (large slope), whereas the starting and end 
points has smaller slopes. In other words, the reaction velocity $V_0$ shows 
sigmoidity as a function of substrate concentration, [aspartate]. 

This tells us that ATCase works by cooperativity in substrate binding 
(i.e. does not obey Michaelis-Menten kinetics model), i.e. binding of one 
susbtrate increases the likelihood that the second substrate will bind 
(you have already encountered this in the topic of protein-ligand interactions).

:::
"""
print(answer)
```

#### (c) Quarternary structure

What does the figure tell us about the quaternary structure of ATCase?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
Allosteric enzymes consist of two or more subunits, each able to bind and process
a substrate molecule. Such enzymes can take at least two different conformational 
states, which are in equilibrium. 

:::
"""
print(answer)
```

#### (d) Effect of CTP

Copy your plotting code from above and add a line to also plot the `rate_ctp_(M/s)` dataset.

```{python}
#| exercise: true
#| eval: false
## Your task: Copy your plotting code and add a line to also plot the rate_ctp_(M/s) dataset.
...
```


```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the datasets
ax.plot(df['[aspartate]_(M)'], df['rate_(M/s)'], label='No CTP')
ax.plot(df['[aspartate]_(M)'], df['rate_ctp_(M/s)'], label='CTP')

ax.set_xlabel('[Aspartate] (M)')
ax.set_ylabel('Rate of formation (M/s)')
ax.legend()
```

Qualitatively describe the effect of CTP on the rate of N-carbamyolaspartate formation

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
CTP lowers the catalytic rate of ATCase, by binding to it and stabilising ATCase in a low substrate-affinity state.

:::
"""
print(answer)
```

#### (e) Physiological advantage

In fact many enzymes are regulated by certain end products in a fashion similar to the CTP effect on ATCase. Can you explain why this might be a physiological advantage?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
As seen from the reaction scheme, the reaction catalyzed by ATCase ultimately 
leads to the formation of CTP. When [CTP] increases the level of CTP formation therefore drops. 

:::
"""
print(answer)
```


#### (g) Regression with Hill equation.

There is also a formulation of the Hill equation for the enzyme kinetics, which has the following form:
$$
v = \frac{V_\mathrm{max} \cdot S^h}{K_{\frac{1}{2}}^h+S^h}
$$

Note, that we use a formulation of the Hill equation, where the constant on the denominator is raised to the power of $h$. 
Therefore, the constant also marks the half-way saturation concentration and we denote it $K_{\frac{1}{2}}$

As usual start by writing a function implementing this equation

```{python}
#| exercise: true
#| eval: false
def hill_eq(S, Vmax, K, h):
    ## Your task: Implement the enzyme kinetics Hill equation.
    result = ...
    return result

print(hill_eq(1, 1, 1, 1)) # Should give 0.5 -> (1 * 1^1) / (1**1 + 1**1) = (1 * 1) / (1 + 1) = 1/2
```

```{python}
#| solution: true
def hill_eq(S, Vmax, K, h):
    ## Your task: Implement the enzyme kinetics Hill equation.
    return (Vmax * S**h) / (K**h + S**h)

print(hill_eq(1, 1, 1, 1)) # Should give 0.5 -> (1 * 1^1) / (1**1 + 1**1) = (1 * 1) / (1 + 1) = 1/2
```
And then make the fit for each dataset of rates vs. aspartate concentration.

```{python}
#| exercise: true
#| eval: false

## Your task: Make the fit for the dataset without CTP
fitted_parameters_noctp, trash = ...
Vmax_fit_noctp, K_fit_noctp, h_fit_noctp = fitted_parameters_noctp

## Your task: Make the fit for the dataset with CTP
fitted_parameters_ctp, trash = ...
Vmax_fit_ctp, K_fit_ctp, h_fit_ctp = fitted_parameters_ctp
```

```{python}
#| solution: true
#| eval: true

## Your task: Make the fit for the dataset without CTP
fitted_parameters_noctp, _ = curve_fit(hill_eq, df['[aspartate]_(M)'], df['rate_(M/s)'])
Vmax_fit_noctp, K_fit_noctp, h_fit_noctp = fitted_parameters_noctp

## Your task: Make the fit for the dataset with CTP
fitted_parameters_ctp, _ = curve_fit(hill_eq, df['[aspartate]_(M)'], df['rate_ctp_(M/s)']) 
Vmax_fit_ctp, K_fit_ctp, h_fit_ctp = fitted_parameters_ctp
```

The next cell prints the fitted parameters for both cases.

```{python}
#| exercise: true
#| eval: false
print('Without CTP')
print('    Vmax', Vmax_fit_noctp)
print('    K1/2', K_fit_noctp)
print('    h', h_fit_noctp)

print('With CTP')
print('    Vmax', Vmax_fit_ctp)
print('    K1/2', K_fit_ctp)
print('    h', h_fit_ctp)
```

```{python}
#| solution: true
print('Without CTP')
print('    Vmax', Vmax_fit_noctp)
print('    K1/2', K_fit_noctp)
print('    h', h_fit_noctp)

print('With CTP')
print('    Vmax', Vmax_fit_ctp)
print('    K1/2', K_fit_ctp)
print('    h', h_fit_ctp)
```

Then we can plot 

```{python}
#| exercise: true
#| eval: false
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Calculate the fits
S_smooth = np.linspace(0, 50*10**(-3))
V_fit_noctp = ...
V_fit_ctp = ...

## Your task: Plot the fits:
...
...

## Plots the datasets
ax.plot(df['[aspartate]_(M)'], df['rate_(M/s)'], 'o', label='No CTP', color='C0')
ax.plot(df['[aspartate]_(M)'], df['rate_ctp_(M/s)'], 'o', label='CTP', color='C1')

## Labels & legend
ax.set_xlabel('[Aspartate] (M)')
ax.set_ylabel('v (M/s)')
ax.legend()
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Calculate the fits
S_smooth = np.linspace(0, 50*10**(-3))
V_fit_noctp = hill_eq(S_smooth, Vmax_fit_noctp, K_fit_noctp, h_fit_noctp)
V_fit_ctp = hill_eq(S_smooth, Vmax_fit_ctp, K_fit_ctp, h_fit_ctp)

## Your task: Plot the fits:
ax.plot(S_smooth, V_fit_noctp)
ax.plot(S_smooth, V_fit_ctp)

## Plots the datasets
ax.plot(df['[aspartate]_(M)'], df['rate_(M/s)'], 'o', label='No CTP', color='C0')
ax.plot(df['[aspartate]_(M)'], df['rate_ctp_(M/s)'], 'o', label='CTP', color='C1')

## Labels & legend
ax.set_xlabel('[Aspartate] (M)')
ax.set_ylabel('Rate of formation (M/s)')
ax.legend()
```

| How do the constants of the Hill equation change in response to the presence of CTP? 
| Does this match your expectations?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
$V_\mathrm{max}$ is basically unchanged. 

$K_{\frac{1}{2}} is increased meaning that a higher aspartate concentration is necessary in order to reach half $V_\mathrm{max}$ - 
this matches with the curve being shifted to the right.

$h$ increases slightly in the presence of CTP making the curve more sigmoidal, so the switch is sharper.

:::
"""
print(answer)
```
