## Enzyme inhibitors (II)

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import curve_fit
import numpy as np
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
pd.set_option('display.max_rows', 6)
```

Two enzyme inhibitors were identified as part of a drug discovery program. To characterize the mechanism of action, the reaction kinetics were analysed for the enzyme alone and in the presence of 5 $\mu$M of each of the inhibitors as a function of substrate concentration resulting in the data in the file `enzyme-inhib-ii.xlsx`

Load the dataset

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('week49_7') # Load from package for the solution so it doesn't require to interact.
display(df)

```

#### (a) Convert & plot

Convert the measurements to SI units and plot the initial reaction velocity versus substrate concentration for all three reactions. 

Start by converting the units 
```{python}
#| exercise: true
#| eval: false

## Your task: Add new columns with the properties in the correct SI units. 
## There are 4 properties, so you should add 4 columns. 
... # Your code to convert units here.
```

```{python}
#| solution: true

## Your task: Add new columns with the properties in the correct SI units. 
## There are 4 properties, so you should add 4 columns. 
df['[S]_(M)'] = df['[S]_(uM)'] * 10**(-6)
df['enz_(M/s)'] = df['enz_(nM/s)'] * 10**(-9)
df['inhibitor2_(M/s)'] = df['inhibitor2_(nM/s)'] * 10**(-9)
df['inhibitor3_(M/s)'] = df['inhibitor3_(nM/s)'] * 10**(-9)
```

And then plot to visualize the data

```{python}
#| exercise: true
#| eval: false

fig, ax = plt.subplots()

## Your task plot each data vs. [S]_(M).
## To distinguish the data its a good idea to use label='enz_(M/s)' and so on.
...
...
...
    
ax.legend()
ax.set_xlabel('Substrate concentration [M]', fontsize=14)
ax.set_ylabel('$V_0$', fontsize=14)
plt.show()
```

```{python}
#| solution: true
#| fig-align: center

fig, ax = plt.subplots()

## Your task plot each data vs. [S]_(M).
ax.plot(df['[S]_(M)'], df['enz_(M/s)'], 'o', label='enz_(M/s)')
ax.plot(df['[S]_(M)'], df['inhibitor2_(M/s)'], 'o', label='inhibitor2_(M/s)')
ax.plot(df['[S]_(M)'], df['inhibitor3_(M/s)'], 'o', label='inhibitor3_(M/s)')

## Adds legend and axis labels. 
ax.legend()
ax.set_xlabel('Substrate concentration (M)')
ax.set_ylabel('V0 (M/s)')
plt.show()
```

#### (b) Estimate parameters

Based on the appearance of these plots:

- Which dataset would have the highest $V_\mathrm{max}$, which the lowest? 
- What about $K_M$? 

Based on your answers,

- Can you determine the type of inhibition? 
- Alternatively, can you exclude some mechanisms?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer

$V_\mathrm{max}$ changes by a lot, with little or no change in $K_M$. This rules out competetive inhibition.

:::
"""
print(answer)
```


#### (c) Fit

As always, we need the function we're fitting with 

```{python}
def michaelis_menten(S, Vmax, Km):
    return (Vmax * S) / (S + Km)
```

And then we can make the fit

```{python}
#| exercise: true
#| eval: false

## Your task fit dataset 1: 'enz_(M/s)'
initial_guess = [..., ...]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['enz_(M/s)'], initial_guess)
Vmax_enz_fit, K_M_enz_fit = fitted_parameters

## Your task fit dataset 2: 'inhibitor2_(M/s)'
initial_guess = [..., ...]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['inhibitor2_(M/s)'], initial_guess)
Vmax_inhib2_fit, K_M_inhib2_fit = fitted_parameters

## Your task fit dataset 3: 'inhibitor2_(M/s)'
initial_guess = [..., ...]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['inhibitor3_(M/s)'], initial_guess)
Vmax_inhib3_fit, K_M_inhib3_fit = fitted_parameters

print('Dataset 1: enz_(M/s)')
print('    V_max', Vmax_enz_fit)
print('    K_M', K_M_enz_fit)
print('Dataset 2: inhibitor2_(M/s)')
print('    V_max', Vmax_inhib2_fit)
print('    K_M', K_M_inhib2_fit)
print('Dataset 3: inhibitor3_(M/s)')
print('    V_max', Vmax_inhib3_fit)
print('    K_M', K_M_inhib3_fit)
```


```{python}
#| solution: true

## Your task fit dataset 1: 'enz_(M/s)'
initial_guess = [3*10**(-9), 0.25*10**(-5)]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['enz_(M/s)'], initial_guess)
Vmax_enz_fit, K_M_enz_fit = fitted_parameters

## Your task fit dataset 2: 'inhibitor2_(M/s)'
initial_guess = [3*10**(-9), 0.25*10**(-5)]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['inhibitor2_(M/s)'], initial_guess)
Vmax_inhib2_fit, K_M_inhib2_fit = fitted_parameters

## Your task fit dataset 3: 'inhibitor2_(M/s)'
initial_guess = [3*10**(-9), 0.25*10**(-5)]
fitted_parameters, trash = curve_fit(michaelis_menten, df['[S]_(M)'], df['inhibitor3_(M/s)'], initial_guess)
Vmax_inhib3_fit, K_M_inhib3_fit = fitted_parameters

print('Dataset 1: enz_(M/s)')
print('    V_max', Vmax_enz_fit)
print('    K_M', K_M_enz_fit)
print('Dataset 2: inhibitor2_(M/s)')
print('    V_max', Vmax_inhib2_fit)
print('    K_M', K_M_inhib2_fit)
print('Dataset 3: inhibitor3_(M/s)')
print('    V_max', Vmax_inhib3_fit)
print('    K_M', K_M_inhib3_fit)
```

```{python}
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Evaluate the fits
S_smooth = np.linspace(0, 2.05*10**(-5), 100)
V0_enz = michaelis_menten(S_smooth, Vmax_enz_fit, K_M_enz_fit)
V0_inhib2 = michaelis_menten(S_smooth, Vmax_inhib2_fit, K_M_inhib2_fit)
V0_inhib3 = michaelis_menten(S_smooth, Vmax_inhib3_fit, K_M_inhib3_fit)

## Plots the fits
ax.plot(S_smooth, V0_enz)
ax.plot(S_smooth, V0_inhib2)
ax.plot(S_smooth, V0_inhib3)

## Plots the data
ax.plot(df['[S]_(M)'], df['enz_(M/s)'], 'o', label='enz_(M/s)', color='C0')
ax.plot(df['[S]_(M)'], df['inhibitor2_(M/s)'], 'o', label='inhibitor2_(M/s)', color='C1')
ax.plot(df['[S]_(M)'], df['inhibitor3_(M/s)'], 'o', label='inhibitor3_(M/s)', color='C2')

## Adds legend and axis labels. 
ax.legend()
ax.set_xlabel('Substrate concentration (M)')
ax.set_ylabel('V0 (M/s)')
plt.show()
```

If your fits don't closely match the data, go back and change your initial guesses. 


#### (d) Type of inhibitor

We call $V_\mathrm{max}$ and $K_\mathrm{M}$ recorded in the presence of the inhibitor for $V_\mathrm{max}^{app}$ and $K_\mathrm{M}^{app}$ ($app = \mathrm{apparent}$).

Calcuate how much each value changes in the presence of the inhibitor by dividing 
them by the parameters determined in the absence of an inhibitor.

```{python}
#| exercise: true
#| eval: false

## Your task: Calculate the ratio nof K_M^app / K_M
K_M_ratio2 = K_M_inhib2_fit / K_M_enz_fit
K_M_ratio3 = K_M_inhib3_fit / K_M_enz_fit

## Your task: Calculate the ratio nof Vmax^app / Vmax
Vmax_ratio2 = Vmax_inhib2_fit / Vmax_enz_fit
Vmax_ratio3 = Vmax_inhib3_fit / Vmax_enz_fit

## Prints the ratios
print('Inhibitor 2')
print('K_M', K_M_ratio2)
print('Vmax', Vmax_ratio2)

print('Inhibitor 3')
print('K_M', K_M_ratio3)
print('Vmax', Vmax_ratio3)
```

```{python}
#| solution: true

## Your task: Calculate the ratio nof K_M^app / K_M
K_M_ratio2 = K_M_inhib2_fit / K_M_enz_fit
K_M_ratio3 = K_M_inhib3_fit / K_M_enz_fit

## Your task: Calculate the ratio nof Vmax^app / Vmax
Vmax_ratio2 = Vmax_inhib2_fit / Vmax_enz_fit
Vmax_ratio3 = Vmax_inhib3_fit / Vmax_enz_fit

## Prints the ratios
print('Inhibitor 2')
print('K_M', K_M_ratio2)
print('Vmax', Vmax_ratio2)

print('Inhibitor 3')
print('K_M', K_M_ratio3)
print('Vmax', Vmax_ratio3)
```

Based on the above, what is the likely inhibition type of inhibitor2 and inhibitor3?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
For inhibitor2 both $K_M$ and $V_\mathrm{max}$ change significantly, making the likely type of inhibition **uncompetitive**.

For inhibitor3 only $V_\mathrm{max}$ changes significantly, making the likely type of inhibition **non-competiive**.

:::
"""
print(answer)
```

#### (e) $K_i$

Determine the $K_i$ for each of the two inhibitors. The inhibitor concentration is 5 $\mu\mathrm{M}$.

```{python}
#| exercise: true
#| eval: false

## Your task: Assign known value
I = ...

## Your task: Calculate K_I for both cases. 
## You should derive the correct expression before doing any coding!
K_I_inhib2 = ...
K_I_inhib3 = ...

## Prints the results
print('Inhibitor 2: ', K_I_inhib2)
print('Inhibitor 3: ', K_I_inhib3)
```

```{python}
#| solution: true

## Your task: Assign known value
I = 5 * 10**(-6)

## Your task: Calculate K_I for both cases. 
## You should derive the correct expression before doing any coding!
K_I_inhib2 = I / (Vmax_enz_fit / Vmax_inhib2_fit - 1)
K_I_inhib3 = I / (Vmax_enz_fit / Vmax_inhib3_fit - 1)

## Prints the results
print('Inhibitor 2: ', K_I_inhib2)
print('Inhibitor 3: ', K_I_inhib3)
```

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer
For both (pure) non-competitive and uncompetitive inhibition we have

$$
V^{app}_\mathrm{max} = \frac{V_\mathrm{max}}{1+\frac{[I]}{K_I}}.
$$

From which we can isolate $K_I$, doing a bit of algebra we get 

$$
K_I = \frac{[I]}{\frac{V_\mathrm{max}}{V^{app}_\mathrm{max}} - 1}.
$$

:::
"""
print(answer)
```
