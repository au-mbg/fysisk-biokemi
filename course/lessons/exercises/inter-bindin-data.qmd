## Interpretation of binding data. 

```{python}
import numpy as np
import pandas as pd
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
pd.set_option('display.max_rows', 6)
```

The `inter-bindin-data.xlsx` contains a protein binding dataset. 

#### (a) Load the dataset

Load the dataset using the widget below

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('interpret_week48') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (b) SI Units

Add a new column to the `DataFrame` with the ligand concentration in SI units.

```{python}
#| exercise: true
#| eval: false

## Your task: Add a column with the concentration in M ##
## Call this column df['[L]_(M)'] ##
## Recall that you can say df['[L]_(M)'] = df["[L]_(uM)"] * XXX ##
## Where XXX is the factor to multiply by. ##
df[...] = df[...] * XXX
display(df)
```

```{python}
#| solution: true

## Your task: Add a column with the concentration in M ##
## Call this column df['[L]_(M)'] ##
## Recall that you can say df['[L]_(M)'] = df["[L]_(uM)"] * XXX ##
## Where XXX is the factor to multiply by. ##
df['[L]_(M)'] = df["[L]_(uM)"] * 10**(-6)
display(df)
```

#### (c) Plot the data 

Make plots of the binding data directly with a linear and logarithmic x-axis. 

Estimate $K_D$ by visual inspection of these plots! 

```{python}
#| exercise: true
#| eval: false
import matplotlib.pyplot as plt

# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2)

## We index with [0] to plot in the first axis. ## 
## Don't worry about remembering this ## 
ax = axes[0]

## Your task: Plot the data [L]_(M) vs nbar.
ax.plot(..., ..., 'o') # Replace ... with your code.


## We index with [0] to plot in the first axis. ## 
## Don't worry about remembering this ## 
## We will make this a log plot ## 
ax = axes[1]

## Your task: Plot the data [L]_(M) vs nbar.
## Same exact code as above
ax.plot(..., ..., 'o') # Replace ... with your code.

## This makes it a log plot ## 
## You do not need to remember or understand this in detail ##
ax.set_xscale('log')
```

```{python}
#| solution: true

# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2)

## We index with [0] to plot in the first axis. ## 
## Don't worry about remembering this ## 
ax = axes[0]
ax.plot(df['[L]_(M)'], df['nbar'], 'o')

## We index with [1] to plot in the first axis. ## 
## Don't worry about remembering this ## 
## We will make this a log plot ## 
ax = axes[1]

## Your task: Plot the data [L]_(M) vs nbar.
## Same exact code as above
ax = axes[1]
ax.plot(df['[L]_(M)'], df['nbar'], 'o')
ax.set_xscale('log')


## EXTRA: You do not need to understand this ## 
## Customization: Adds labels for the axis in both plots. 
ax = axes[0]
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)

ax = axes[1]
ax.set_xlabel('log [L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
```

::: {.callout-note}

Ths command `ax.set_xscale('log')` tells `matplotlib` that we want the x-axis to use a log-scale.

::: 

```{python}
#| exercise: true
#| eval: false
K_D_estimate = ...
```

```{python}
#| solution: true
K_D_estimate = 5 * 10**(-5)
```

#### (d) Make a fit

Make a fit to determine $K_D$, as always we start by implementing the function 
to fit with

```{python}
#| exercise: true
#| eval: false
def nbar(L, K_D):
    ## Your task: Implement the function to fit with
    ## Use your biochemical knowledge to decide which function that is. 
    result = ...
    return result
```

```{python}
#| solution: true
def n_bar(L, K_D):
    ## Your task: Implement the function to fit with
    ## Use your biochemical knowledge to decide which function that is. 
    return L / (L + K_D)
```

And then we can make the fit

```{python}
#| exercise: true
#| eval: false

## Your task: Choose the variables from the dataframe ## 
x = ... # Choose x-data from the dataframe
y = ... # Choose y-data from the dataframe

## Initial guess ## 
initial_guess = [K_D_estimate] # Using your estimate as the initial value for K_D

## Your task: Finish the curve fitting
fitted_parameters, trash = ... # Call the curve_fit function.

# Print the parameters
K_D_fit = fitted_parameters[0]
print(K_D_fit)
```

```{python}
#| solution: true

## Your task: Choose the variables from the dataframe ## 
x = df['[L]_(M)']
y = df['nbar']

# Initial guess
initial_guess = [K_D_estimate]

## Your task: Finish the curve fitting
fitted_parameters, trash = curve_fit(n_bar, x, y, initial_guess)

# Print the parameters
K_D_fit = fitted_parameters[0]
print(K_D_fit)
```

#### (e) Compare 

Compare the fitted values with your guess.

```{python}
#| exercise: true
#| eval: false
## These lines make equally spaced points on a normal linear axis ##
## And on a logarithmic axis. ##
L_smooth = np.linspace(0, df['[L]_(M)'].max(), 100)
L_smooth_log = np.geomspace(df['[L]_(M)'].min(), df['[L]_(M)'].max(), 100)

## Youe task: Evaluate the fitted function with L_smooth and L_smooth_log ##
nbar_fit = n_bar(..., K_D_fit)
nbar_fit_log = n_bar(..., K_D_fit)
```

```{python}
#| solution: true

## These lines make equally spaced points on a normal linear axis ##
## And on a logarithmic axis. ##
L_smooth = np.linspace(0, df['[L]_(M)'].max(), 100)
L_smooth_log = np.geomspace(df['[L]_(M)'].min(), df['[L]_(M)'].max(), 100)

## Youe task: Evaluate the fitted function with L_smooth and L_smooth_log ##
nbar_fit = n_bar(L_smooth, K_D_fit)
nbar_fit_log = n_bar(L_smooth_log, K_D_fit)
```

Now we can make a plot. 

```{python}
#| exercise: true
#| eval: false

## This plot uses some extra commands to make it look nice, don't worry 
## about it -  you don't need to understand all the details. 

# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Index with [0] to plot in the first axis - Linear plot
ax = axes[0]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth, nbar_fit, color='C2')

ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.legend()

# Index with [1] to plot in the second axis - Log plot.
ax = axes[1]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth_log, nbar_fit_log, color='C2')

ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.legend()
ax.set_xscale('log')
```

```{python}
#| solution: true
# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Index with [0] to plot in the first axis - Linear plot
ax = axes[0]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth, nbar_fit, color='C2')

ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.legend()

# Index with [1] to plot in the second axis - Log plot.
ax = axes[1]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth_log, nbar_fit_log, color='C2')

ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.legend()
ax.set_xscale('log')
```

#### (f) Saturation 

Based on the value of $K_D$ found from the fit, 

- At which concentration do you expect 10% saturation?
- At which concentration do you expect 90% saturation?

```{python}
#| solution: true
#| eval: false
"""
At K_D/9 and 9*K_D.
"""
```