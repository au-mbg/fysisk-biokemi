## Interpretation of binding data. 

```{python}
import numpy as np
```

The `inter-bindin-data.xlsx` contains a protein binding dataset. 

#### (a) Load the dataset

Load the dataset using the widget below

```{python}
#| eval: false
import numpy as np
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('interpret_week48') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (b) SI Units

Add a new column to the `DataFrame` with the ligand concentration in SI units.

```{python}
#| exercise: true
#| eval: false
... # Replace ... with your code.
display(df)
```

```{python}
#| solution: true
df['[L]_(M)'] = df["[L]_(uM)"] * 10**(-6)
display(df)
```

#### (c) Plot the data 

Make plots of the binding data directly with a linear and logarithmic x-axis. 

Estimate $K_D$ by visual inspection of these plots! 

```{python}
#| exercise: true
#| eval: false
import matplotlib.pyplot as plt

# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Can with [0] to plot in the first axis.
ax = axes[0]
ax.plot(..., ..., 'o') # Replace ... with your code.
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)

ax = axes[1]
... # Put some code here - perhaps you can copy it from somewhere?
ax.set_xscale('log') # This make the x-axis logarithmic.
```

```{python}
#| solution: true
import matplotlib.pyplot as plt

# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Can with [0] to plot in the first axis.
ax = axes[0]
ax.plot(df['[L]_(M)'], df['nbar'], 'o') # Replace ... with your code.
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)

ax = axes[1]
ax.plot(df['[L]_(M)'], df['nbar'], 'o')
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.set_xscale('log')
```

::: {.callout-note}

Ths command `ax.set_xscale('log')` tells `matplotlib` that we want the x-axis to use a log-scale.

::: 

```{python}
#| exercise: true
#| eval: false
K_D_estimate = ...
```

```{python}
#| solution: true
K_D_estimate = 5 * 10**(-5)
```

#### (d) Make a fit

Make a fit to determine $K_D$, as always we start by implementing the function 
to fit with

```{python}
#| exercise: true
#| eval: false
def ... # Give the function an appropriate name.
    return ... # Implement the expression for nbar
```

```{python}
#| solution: true
def n_bar(L, K_D):
    return L / (L + K_D)
```

And then we can make the fit

```{python}
#| exercise: true
#| eval: false
from scipy.optimize import curve_fit

# Choose the variables from the dataframe
x = ... # Choose x-data from the dataframe
y = ... # Choose y-data from the dataframe

# Initial guess
p0 = [K_D_estimate] # Using your estimate as the initial value for K_D

# Bounds
bounds = (0, np.inf) # We limit the parameters to be positve.

# Curve fit
popt, pcov = ... # Call the curve_fit function.

# Print the parameters
K_D_fit = popt[0]
print(f"{K_D_fit = :e}")
```

```{python}
#| solution: true
from scipy.optimize import curve_fit

# Choose the variables from the dataframe
x = df['[L]_(M)']
y = df['nbar']

# Initial guess
p0 = [K_D_estimate]

# Bounds
bounds = (0, np.inf) # We limit the parameters to be positve.

# Curve fit
popt, pcov = curve_fit(n_bar, x, y, p0=p0, bounds=bounds)

# Print the parameters
K_D_fit = popt[0]
print(f"{K_D_fit = :e}")
```

#### (e) Compare 

Make a plot to compare the fit with your estimate. Start by evaluating the 
function

```{python}
#| exercise: true
#| eval: false
# Evaluate on the fit so we can plot it.
L_smooth = np.linspace(0, df['[L]_(M)'].max(), 100)
nbar_fit = ...

# We will also evaluate where the points are sampled on a log-scale.
# The `geomspace` function makes points uniformly spaced on a logaritmic axis.
L_smooth_log = np.geomspace(df['[L]_(M)'].min(), df['[L]_(M)'].max(), 100)
nbar_fit_log = ...
```

```{python}
#| solution: true
# Evaluate on the fit so we can plot it.
L_smooth = np.linspace(0, df['[L]_(M)'].max(), 100)
nbar_fit = n_bar(L_smooth, K_D_fit)

# We will also evaluate where the points are sampled on a log-scale.
# The `geomspace` function makes points uniformly spaced on a logaritmic axis.
L_smooth_log = np.geomspace(df['[L]_(M)'].min(), df['[L]_(M)'].max(), 100)
nbar_fit_log = n_bar(L_smooth_log, K_D_fit)
```

Now finish the code below to make the plot.

```{python}
#| exercise: true
#| eval: false
# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Index with [0] to plot in the first axis - Linear plot
ax = axes[0]

# Your code here - maybe you can copy part of it from somewhere.
... 

# Index with [1] to plot in the second axis - Log plot.
ax = axes[1]

# Also your code here - maybe you can copy part of it from somewhere.
...

ax.set_xscale('log')
```

```{python}
#| solution: true
# This makes a figure with two axes.
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# Index with [0] to plot in the first axis - Linear plot
ax = axes[0]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth, nbar_fit, color='C2')

ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.legend()

# Index with [1] to plot in the second axis - Log plot.
ax = axes[1]
ax.plot(df['[L]_(M)'], df['nbar'], 'o', color='C0')
ax.plot(L_smooth_log, nbar_fit_log, color='C2')

ax.set_xlabel('[L](M)', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
ax.axvline(K_D_estimate, label='Estimate', color='C1')
ax.axvline(K_D_fit, label='Fit', color='C2')
ax.legend()
ax.set_xscale('log')
```

#### (f) Saturation 

Based on the value of $K_D$ found from the fit, 

- At which concentration do you expect 10% saturation?
- At which concentration do you expect 90% saturation?

```{python}
#| solution: true
#| eval: false
"""
At K_D/9 and 9*K_D.
"""
```