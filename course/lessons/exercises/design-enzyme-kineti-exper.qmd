## Design of an enzyme kinetics experiment

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
pd.set_option('display.max_rows', 6)
```

We have finally arrived at the part of the course where we are ready to analyse the data from your lab exercise in the first quarter. First, however we will analyse a similar data set where we are sure about the data quality (ðŸ˜‰) to illustrate the process.

In the Excel document `design-enzyme-kineti-exper.xlsx` you will find a data set in which an enzyme
catalyzed formation of product P, with varying start concentration of substrates, 
[S], was followed over time. The product absorbs light at a specific wavelength 
with an extinction coefficient of 0.068 $\mu\text{M}^{-1}\cdot \text{cm}^{-1}$, and the absorbance was measured 
in a light path of 1 cm throughout the time course.

You can load the dataset using the cells below; 

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('design-enzyme-kineti-exper.xlsx') # Load from package for the solution so it doesn't require to interact.
display(df)
```

The headers, like `Abs_S1` refer to the substrate concentration so `S1` means a substrate concentration of 1 $\mu\text{M}$.

#### (a) Connvert extinction coefficient to SI.
Convert the extinction coefficient to units given in $\text{M}^{-1}\cdot \text{cm}^{-1}$ and 
assign it to a variable. Also assign the light path length to a variable.

```{python}
#| exercise: true
#| eval: false

## Your task: Assign known values in SI units.
...
...
```

```{python}
#| solution: true

## Your task: Assign known values in SI units.
ext_coeff = 0.068 / 10**(-6) # 1/(M cm)
l = 1 # cm
```

#### (b) Calculate concentrations

Using Lambert-Beers law, calculate the concentration of product, $[P]$, in $\text{M}$ for each time series.

The cell below setups a loop calculate the concentrations for each of these current columns in the dataframe.

```{python}
#| exercise: true
#| eval: false

## Your task calculate the concentration for each 'Abs_SX' column and add it ##
## as a new column. 
df['C_S1'] = ...
df['C_S2'] = ...
df['C_S4'] = ...
df['C_S8'] = ...
df['C_S16'] = ...
df['C_S32'] = ...
df['C_S64'] = ...
df['C_S128'] = ...
df['C_S256'] = ...
```

```{python}
#| solution: true

## Your task calculate the concentration for each 'Abs_SX' column and add it ##
## as a new column. 
df['C_S1'] = df['Abs_S1'] / (ext_coeff * l)
df['C_S2'] = df['Abs_S2'] / (ext_coeff * l)
df['C_S4'] = df['Abs_S4'] / (ext_coeff * l)
df['C_S8'] = df['Abs_S8'] / (ext_coeff * l)
df['C_S16'] = df['Abs_S16'] / (ext_coeff * l)
df['C_S32'] = df['Abs_S32'] / (ext_coeff * l)
df['C_S64'] = df['Abs_S64'] / (ext_coeff * l)
df['C_S128'] = df['Abs_S128'] / (ext_coeff * l)
df['C_S256'] = df['Abs_S256'] / (ext_coeff * l)
```

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Alternative solution

A more advanced alternative solution is to use a for-loop like done below, however
this is outside the scope of what you're going to learn in this course. 

:::
"""
print(answer)
```

```{python}
#| solution: true
#| eval: false
for s in [1, 2, 4, 8, 16, 32, 64, 128, 256]: 
    df[f'C_{s}'] = df[f'Abs_S{s}'] / (ext_coeff * l)
```


And we can check that the columns we expect have been added to the `DataFrame`.

```{python}
#| exercise: true
#| eval: false
display(df)
```
```{python}
#| solution: true
display(df)
```

#### (c) Plot

We focus now on the `C_S32`-column and plot it versus the time measurements.

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

## Your task: Plot the C_S32 column 
ax.plot(df['time_(s)'], df['C_S32'])

## EXTRA: 
ax.set_xlabel('Time (s)')
ax.set_ylabel('Concentration (M)')
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Your task: Plot the C_S32 column 
ax.plot(df['time_(s)'], df['C_S32'])

## EXTRA: 
ax.set_xlabel('Time (s)')
ax.set_ylabel('Concentration (M)')
```

#### (d) Extracting $V_0$.

In enzyme kinetics, we usually focus on the initial time points, i.e. before the 
reaction has progressed far enough to allow products to be accumulated and substrate
to be depleted. In this early stage of the reaction, we know that the concentration 
has not changed significantly yet and thus the [S] = S0. Therefore, the reaction 
time course tends to be linear in this range. 

In the following, we want to just fit the initial part of the curve. We do this by 
defining a new data array containing only the first values. 

We want to use Python to determine $V_0$ for each concentration of $S$, in order 
to create a table of $V_0$ vs $[S]$. To do so we will fit linear functions to the
initial parts of the curves, as the slope of these is then $V_0$.

Start by defining a linear function; 

```{python}
#| exercise: true
#| eval: false
def linear_func(x, a, b):
    ## Your task: Finish implementing the linear function
    return ...
```

```{python}
#| solution: true
def linear_func(x, a, b):
    return a * x + b
```

As mentioned we want to to get the slope in the initial part of the reaction, 
where the curves are approximately linear. To do so we need to fit not on 
all the data-points but only some of them. 

We will first do this for the `C_S32`-column. 

```{python}
#| exercise: true
#| eval: false

## Determine the x and y data
x_data_full = df['time_(s)']
y_data_full = df['C_S32']

## Your task: Set n_points to choose the number of points to fit with.
n_points = ...
x_data = x_data_full[0:n_points] # This picks the first n_points points.
y_data = y_data_full[0:n_points] # This picks the first n_points points.

## Your task: Make the fit.
fitted_parameters, trash = curve_fit(..., ..., ...)
a, b = fitted_parameters
```

```{python}
#| solution: true
#| fig-align: center

## Determine the x and y data
x_data_full = df['time_(s)']
y_data_full = df['C_S32']

## Your task: Set n_points to choose the number of points to fit with
n_points = 5
x_data = x_data_full[0:n_points] # This picks the first n_points points.
y_data = y_data_full[0:n_points] # This picks the first n_points points.

## Your task: Make the fit.
fitted_parameters, trash = curve_fit(linear_func, x_data, y_data)
a, b = fitted_parameters
```

The cell below plots your fit alongside the data

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()
t_smooth = np.linspace(0, 20)
y_fit = linear_func(t_smooth, a, b)
ax.plot(x_data_full, y_data_full, 'o')
ax.plot(t_smooth, y_fit)
ax.set_xlabel('Time (s)')
ax.set_ylabel('Concentration')
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()
t_smooth = np.linspace(0, 20)
y_fit = linear_func(t_smooth, a, b)
ax.plot(x_data_full, y_data_full, 'o')
ax.plot(t_smooth, y_fit)
ax.set_xlabel('Time (s)')
ax.set_ylabel('Concentration')
```

You want the line to fit well with the initial approximately linear part of the data, 
adjust `n_points` such that this is the case. 

#### (e) Using all the datasets

In the cell below `n_points` again determines the number of data-points used for the linear fit, 
and makes the fits and plots for every dataset.

```{python}
#| fig-align: center
#| exercise: true
#| eval: false
from fysisk_biokemi.utils.design_enzyme_kineti_exper import make_fits_and_plots

## Your task: Select a number of points to fit with that is appropriate in 
## all cases
n_points = ...

## This function does what you did in the previous exercise but for all the datasets. ##
slopes, concentrations = make_fits_and_plots(df, n_points)
```

```{python}
#| fig-align: center
#| solution: true
from fysisk_biokemi.utils.design_enzyme_kineti_exper import make_fits_and_plots

## Your task: Select a number of points to fit with that is appropriate in 
## all cases
n_points = 5

## This function does what you did in the previous exercise but for all the datasets. ##
slopes, concentrations = make_fits_and_plots(df, n_points)
```

::: {.callout-note collapse="true"}

## Information on 'make_fits_and_plot'

The function 'make_fits_and_plots' is beyond what is expected for this course, however if you are 
interested you can see the source code for it on [github](https://github.com/au-mbg/fysisk-biokemi/blob/main/src/fysisk_biokemi/utils/design_enzyme_kineti_exper.py).

:::

Once you're satisfied with the fit you can display the collected slopes with the cell below 

```{python}
#| exercise: true
#| eval: false
V0_df = pd.DataFrame({'[S]_(M)': concentrations, 'V0_(M/s)': slopes})
display(V0_df)
```


```{python}
#| solution: true
V0_df = pd.DataFrame({'[S]_(M)': concentrations, 'V0_(M/s)': slopes})
display(V0_df)
```

#### (f) Understanding of $V_0$
Why is it important to use $V_0$ rather than $V$ at a later time point when creating the Michaelis-Menten plot?

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Answer

The initial velocities, $V_0$, represent velocities in which the consumption/formation is only dependent on substrate concentration as no product is yet formed.

:::
"""
print(answer)
```

:::::: {.cell .markdown}

::::::


#### (g) Plotting again.

Plot $V_0$ against substrate concentration and estimate $k_{cat}$ and $K_M$ visually (remember units) 

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

# Your task: Plot the V0_(M/s) versus [S_(M)]
...
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

# Your task: Plot the V0_(M/s) versus [S_(M)]
ax.plot(V0_df['[S]_(M)'], V0_df['V0_(M/s)'], 'o')

## EXTRA: Axis labels.
ax.set_xlabel('[S] (M)')
ax.set_ylabel('$V_0$ (M/s)')
```

Use the figure to estimate the value of $K_M$ and $V_\text{max}$ and put those in the cell below.

```{python}
#| exercise: true
#| eval: false

# Your task: Put your estimated values here: 
K_M_estimate = ...
V_max_estimate = ...
```

```{python}
#| solution: true

# Your task: Put your estimated values here: 
K_M_estimate = 30 * 10**(-6)
V_max_estimate = 10 * 10**(-7)
```

#### (h) Fitting with Michealis-Menten

Now we can fit with the Michealis-Menten equation, as always in a fitting 
task we need to implement the model.

```{python}
#| exercise: true
#| eval: false
def michaelis_menten(S, K_M, V_max):
    ## Your task: Implement the Michaelis-Menten model.
    result = ...
    return result
```

```{python}
#| solution: true
def michaelis_menten(S, K_M, V_max):
    ## Your task: Implement the Michaelis-Menten model.
    result = (V_max * S) / (K_M + S)
    return result
```

Then use the next two cells to make the fit and plot it.

```{python}
#| exercise: true
#| eval: false

## Uses your estimate as initial guess
initial_guess = [K_M_estimate, V_max_estimate]
fitted_parameters, trash = curve_fit(michaelis_menten, V0_df['[S]_(M)'], V0_df['V0_(M/s)'], initial_guess)

## Extract and prints the parameters
K_M_fit, V_max_fit = fitted_parameters
print(K_M_fit)
print(V_max_fit)
```

```{python}
#| solution: true

## Uses your estimate as initial guess
initial_guess = [K_M_estimate, V_max_estimate]
fitted_parameters, trash = curve_fit(michaelis_menten, V0_df['[S]_(M)'], V0_df['V0_(M/s)'], initial_guess)

## Extract and prints the parameters
K_M_fit, V_max_fit = fitted_parameters
print(K_M_fit)
print(V_max_fit)
```

How do these compare to your estimates of the two parameters? 

```{python}
#| exercise: true
#| fig-align: center
#| eval: false
fig, ax = plt.subplots()

## Evaluates the fit
S_smooth = np.linspace(0, 0.0003, 100)
V0_fit = michaelis_menten(S_smooth, K_M_fit, V_max_fit)

## Plots the fit and the data.
ax.plot(S_smooth, V0_fit)
ax.plot(V0_df['[S]_(M)'], V0_df['V0_(M/s)'], 'o')

## Axis labels.
ax.set_xlabel('[S] (M)')
ax.set_ylabel('$V_0$ (M/s)');
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots()

## Evaluates the fit
S_smooth = np.linspace(0, 0.0003, 100)
V0_fit = michaelis_menten(S_smooth, K_M_fit, V_max_fit)

## Plots the fit and the data.
ax.plot(S_smooth, V0_fit)
ax.plot(V0_df['[S]_(M)'], V0_df['V0_(M/s)'], 'o')

## Axis labels.
ax.set_xlabel('[S] (M)')
ax.set_ylabel('$V_0$ (M/s)');
```

