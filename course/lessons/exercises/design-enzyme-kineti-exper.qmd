## Design of an enzyme kinetics experiment

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
```

In the Excel document `design-enzyme-kineti-exper.xlsx` you will find a data set in which an enzyme
catalyzed formation of product P, with varying start concentration of substrates, 
[S], was followed over time. The product absorbs light at a specific wavelength 
with an extinction coefficient of 0.068 $\mu\text{M}^{-1}\cdot \text{cm}^{-1}$, and the absorbance was measured 
in a light path of 1 cm throughout the time course.

You can load the dataset using the cells below; 

```{python}
#| eval: false
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('design-enzyme-kineti-exper.xlsx') # Load from package for the solution so it doesn't require to interact.
display(df)
```

The headers, like `Abs_S1` refer to the substrate concentration so `S1` means a substrate concentration of 1 $\mu\text{M}$.

#### (a) Connvert extinction coefficient to SI.
Convert the extinction coefficient to units given in $\text{M}^{-1}\cdot \text{cm}^{-1}$ and 
assign it to a variable. Also assign the light path length to a variable.

```{python}
#| exercise: true
#| eval: false
...
...
```

```{python}
#| solution: true
ext_coeff = 0.068 / 10**(-6) # 1/(M cm)
l = 1 # cm
```

#### (b) Calculate concentrations

Using Lambert-Beers law, calculate the concentration of product, [P], in M for each time series.

::: {.callout-note title="Loops"}
Loops are one of the most useful parts of programming, loops allows us to repeat an operation 
on many different elements. This allows us to not have to repeat code many times, making it 
simpler to understand and less prone to error - and at the same time more flexible. 

A common type of loop in Python is the `for` loop, which does something `for` every item it is 
told to consider. The syntax of a `for`-loop is like so: 

```python
total = 0
for count in [1, 2, 3, 4, 5]:
    print(f"I have {count} apples.")
```
Which will print 
```
I have 1 apples
I have 2 apples
I have 3 apples
I have 4 apples
I have 5 apples
```
So the `for`-loop did the operation of printing a string for each value of `count`. 

When working with a `DataFrame` like in this exercise, we may for example want to do something `for` 
each column, one way of doing that is to loop over the column names, say we want we have a `DataFrame` `df` with 
columns named `"col1", "col2", "col3"` we can loop over that as 
```python
for name in ['col1', 'col2', 'col3']
    df[name] = ... # Some operation
```
::: 

The cell below setups a loop calculate the concentrations for each of these current columns in the dataframe.

```{python}
#| exercise: true
#| eval: false
substrate_concentrations = [1, 2, 4, 8, 16, 32, 64, 128, 256]
for s in substrate_concentrations:
    abs_col_name = f'Abs_S{s}' # This creates a string where the value of 's' is put instead of "{s}"".
    conc_col_name = f'C_S{s}' # Same type string creation 
    df[conc_col_name] = ... # Your code here

    # We can print in each iteration of the loop to see what's going on.
    print(s, abs_col_name, conc_col_name) 
```

```{python}
#| solution: true
substrate_concentrations = [1, 2, 4, 8, 16, 32, 64, 128, 256]
for s in substrate_concentrations:
    abs_col_name = f'Abs_S{s}' # This creates a string where the value of 's' is put instead of "{s}"".
    conc_col_name = f'C_S{s}' # Same type string creation 
    df[conc_col_name] = df[abs_col_name] / (ext_coeff * l)
    print(s, abs_col_name, conc_col_name)
```

And we can check that the columns we expect have been added to the `DataFrame`.

```{python}
#| exercise: true
#| eval: false
display(df)
```
```{python}
#| solution: true
display(df)
```

#### (c) Plot 

Plot [P] as a function of time for all experiments in one single graph. 

Here it is again very useful to use a `for`-loop

```{python}
fig, ax = plt.subplots(figsize=(7, 4))

x_axis = df['time_(s)']
substrate_concentrations = [1, 2, 4, 8, 16, 32, 64, 128, 256]
for s in substrate_concentrations:
    conc_col_name = f'C_S{s}'
    y_axis = df[conc_col_name]

    ax.plot(x_axis, y_axis, label=conc_col_name)    

    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Concentration (M)')


ax.legend()    
```

#### (d) Extracting $V_0$.
We want to use Python to determine $V_0$ for each concentration of $S$, in order to create a table of $V_0$ vs $[S]$. To do so we will fit linear functions to the initial parts of the curves, 
as the slope of these is then $V_0$.

Start by defining a linear function; 

```{python}
#| exercise: true
#| eval: false
def linear_func(x, a, b):
    return ...
```

```{python}
#| solution: true
def linear_func(x, a, b):
    return a * x + b
```

As mentioned we want to to get the slope in the initial part of the reaction, 
where the curves are approximately linear. To do so we need to fit not on 
all the data-points but only some of them. 

In the cell below `n_points` determines the number of data-points used for the linear fit. 
Use this cell to find an appropriate value of `n_points`.

```{python}
#| exercise: true
#| eval: false

# The number of points used to make the fit
n_points = ...

# Variables to store calculated values.
slopes = []
concentrations = []

fig, axes = plt.subplots(3, 3, figsize=(8, 8), sharex=True, sharey='row') # We make the figure while also finding the slopes.
for i, (s, ax) in enumerate(zip(substrate_concentrations, axes.flatten())): # Don't worry about the details of this.

    # Make the
    conc_col_name = f'C_S{s}'
    x_data = df['time_(s)'][:n_points]
    y_data = df[conc_col_name][:n_points]
    popt, pcov = curve_fit(linear_func, x_data, y_data)

    # Plot the data
    ax.plot(df['time_(s)'], df[conc_col_name], 'o', color=f'C{i}', label=f'[S]={s} uM')

    # Plot the fit
    t_smooth = np.linspace(0, 10, 10)
    ax.plot(t_smooth, linear_func(t_smooth, *popt), color='black', linestyle='-')

    # Customize
    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Concentration (M)')
    ax.legend()

    # Store calculated slopes and concentrations, concentration converted to molar.
    slopes.append(popt[0])
    concentrations.append(s * 10**(-6))
```

```{python}
#| solution: true
#| fig-align: center

# The number of points used to make the fit
n_points = 5

# Variables to store calculated values.
slopes = []
concentrations = []

fig, axes = plt.subplots(3, 3, figsize=(8, 8), sharex=True, sharey='row') # We make the figure while also finding the slopes.
for i, (s, ax) in enumerate(zip(substrate_concentrations, axes.flatten())): # Don't worry about the details of this.

    # Make the
    conc_col_name = f'C_S{s}'
    x_data = df['time_(s)'][:n_points]
    y_data = df[conc_col_name][:n_points]
    popt, pcov = curve_fit(linear_func, x_data, y_data)

    # Plot the data
    ax.plot(df['time_(s)'], df[conc_col_name], 'o', color=f'C{i}', label=f'[S]={s} uM')

    # Plot the fit
    t_smooth = np.linspace(0, 10, 10)
    ax.plot(t_smooth, linear_func(t_smooth, *popt), color='black', linestyle='-')

    # Customize
    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Concentration (M)')
    ax.legend()

    # Store calculated slopes and concentrations, concentration converted to molar.
    slopes.append(popt[0])
    concentrations.append(s * 10**(-6))
```

Once you're satisfied with the fit you can display the collected slopes with the cell below 

```{python}
#| solution: true
V0_df = pd.DataFrame({'[S]_(M)': concentrations, 'V0_(M/s)': slopes})
display(V0_df)
```

#### (e) Understanding of $V_0$
Why is it important to use $V_0$ rather than $V$ at a later time point when creating the Michaelis-Menten plot?

#### (f) Plotting again.

Plot $V_0$ against substrate concentration and estimate $k_{cat}$ and $K_M$ visually (remember units) 

```{python}
#| exercise: true
#| eval: false

fig, ax = plt.subplots()

# Make the plot
...

# Customize with axis labels
...
...
```

```{python}
#| solution: true
#| fig-align: center

fig, ax = plt.subplots()
ax.plot(V0_df['[S]_(M)'], V0_df['V0_(M/s)'], '-o')

ax.set_xlabel('[S] (M)', fontsize=14)
ax.set_ylabel('$V_0$ (M/s)', fontsize=14);
```

```{python}
#| exercise: true
#| eval: false

# Put your estimated values here: 
k_cat_estimate = ...
K_M_estimate = ...

```