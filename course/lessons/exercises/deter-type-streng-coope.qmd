## Determination of type and strength of cooperativity

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
import numpy as np
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
from scipy.optimize import curve_fit
```

The binding of NAD+ to the protein yeast glyceraldehyde 3-phosphate dehydrogenase (GAPDH) was studied using
equilibrium dialysis. The enzyme concentration was 71 Î¼M. The concentration of $[\text{NAD}^{+}_\text{free}]$ and the corresponding values of $\bar{n}$ were determined with the resulting data found in the dataset `deter-type-streng-coope.xlsx`.

The dataset consists of three independent repititions of the same experiment.

#### (a) Load the dataset

Load the dataset using the widget below

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('determination_coop_week48') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (b) Averaging and units. 

Start by adding a new column to the `DataFrame` with the average value of $\bar{n}$ across the three series

::: {.callout-tip}
Remember that you can set a new column based on a computation using one or more other columns, e.g. 

```python
df['new_col'] = df['col1'] + df['col2']
```
::: 

```{python}
#| exercise: true
#| eval: false

## Your task: Calculate the of the values in the three columns ##
## nbar1, nbar2, nbar3 ##
df['nbar_avg'] = ...
```

```{python}
#| solution: true

## Your task: Calculate the of the values in the three columns ##
## nbar1, nbar2, nbar3 ##
df['nbar_avg'] = (df['nbar1'] + df['nbar2'] + df['nbar3']) / 3
```

Now also add a column with the ligand concentration in SI units with the column-name `[NAD+free]_(M)`.

```{python}
#| exercise: true
#| eval: false

## Task: Calculate the ligand concentration in M and ##
## set it as a new column with the name '[NAD+free]_(M)'
... # Your code here. 
display(df)
```

```{python}
#| solution: true

## Task: Calculate the ligand concentration in M and ##
## set it as a new column with the name '[NAD+free]_(M)'
df['[NAD+free]_(M)'] = df['[NAD+free]_(uM)'] * 10**(-6)
display(df)
```

Finally, set the concentration of the GADPH in SI units

```{python}
#| exercise: true
#| eval: false

## Task: Convert the GADPH concentration to M  ## 
## Set it to the variable c_gadph ## 
## Add a comment about the unit ##
c_gadph = ...
```

```{python}
#| solution: true

## Task: Convert the GADPH concentration to M  ## 
## Set it to the variable c_gadph ## 
## Add a comment about the unit ##
c_gadph = 71 * 10**(-6) # M
```

#### (c) Plot

Make a plot of the average $\bar{n}$ as a function of $[\text{NAD}^{+}_\text{free}]$.

```{python}
#| exercise: true
#| eval: false

fig, ax = plt.subplots()

## Your task: Add plot of nbar vs [NAD+_free]_(M)
... 
```

```{python}
#| solution: true
#| fig-align: center

fig, ax = plt.subplots()

## Your task: Add plot of nbar vs [NAD+_free]_(M)
ax.plot(df['[NAD+free]_(M)'], df['nbar_avg'], 'o')

## EXTRA: You don't need to understand this
## Customization
ax.set_xlabel(r'$[\text{NAD}^{+}_\text{free}]$', fontsize=14)
ax.set_ylabel(r'$\bar{n}$', fontsize=14)
plt.show()
```

#### (d) Scatchard plot

Make a Scatchard plot based on the average $\bar{n}$.

```{python}
#| exercise: true
#| eval: false

# Your task: Calculate nbar / L 
nbar_over_L = ...

fig, ax = plt.subplots() 

# Your task: Choose the right things to make a Scatchard plot. 
ax.plot(..., ... 'o')
```

```{python}
#| solution: true
#| fig-align: center

# Your task: Calculate nbar / L 
nbar_over_L = df['nbar_avg'] / df['[NAD+free]_(M)']

fig, ax = plt.subplots() 

# Your task: Choose the right things to make a Scatchard plot. 
ax.plot(df['nbar_avg'], nbar_over_L, 'o')

## EXTRA: You dont need to understand this. 
## Adds customization. 
ax.set_xlabel(r'$\bar{n}$', fontsize=14)
ax.set_ylabel(r'$\bar{n}/L$', fontsize=14)
ax.set_xlim([0, df['nbar_avg'].max()*1.2])
ax.set_ylim([0, nbar_over_L.max() * 1.2])
```

#### (e) Binding sites

Estimate by eye how many bindings sites GAPDH contains for $\text{NAD}^{+}$?

```{python}
#| solution: true
#| eval: false
"""
Saturation suggest assumptotic approximation to 4, which seems like the like 
intercept of the non-linear scatchard plot.
"""
```

#### (f) Cooperativity 

Based on a visual inspection of the plot above, are there in signs of cooperativity? If so, which kind?

```{python}
#| solution: true
#| eval: false
"""
Positive cooperativity as witnessed e.g. by the increasing slope in the early 
part of the lienar plot
"""
```


#### (g) Fit

Make a fit using the functional form 

$$
\bar{n} = N \frac{[L]^h}{K_D + [L]^h}
$$

As usual, start by defining the function in Python 

```{python}
#| exercise: true
#| eval: false
def n_bar(L, N, K_D, h):
    ## Your task: Implement the function
    # Be careful with parentheses!
    result = ...
    return result 
```

```{python}
#| solution: true
def n_bar(L, N, K_D, h):
    ## Your task: Implement the function
    # Be careful with parentheses!
    result = N * L**h / (K_D + L**h)
    return result
```


Now we can fit

```{python}
#| exercise: true
#| eval: false

## We want to use all the data for the fit, but it was given in three different columns. 
## We stitch it together to make a column containing all x-coordinates 
## And another column containing all y-coordinates
x = np.concatenate([df['[NAD+free]_(M)'], df['[NAD+free]_(M)'], df['[NAD+free]_(M)']])
y = np.concatenate([df['nbar1'], df['nbar2'], df['nbar3']])

## Your task: Make initial guesses for the three parameters
## The order is that of the function 
## So N, K_D and h.
initial_guess = [..., ..., ...]

## Your task: Make the fit
## Note: The bounds argument has been added to have the function 
## only explore positive sets of parameters. 
fitted_parameters, trash = curve_fit(..., ..., ..., ..., bounds=(0, np.inf))

# Print the parameters
N_fit, K_D_fit, h_fit = fitted_parameters
print('N_fit', N_fit)
print('K_D_fit', K_D_fit)
print('h_fit', h_fit)
```

```{python}
#| solution: true

## We want to use all the data for the fit, but it was given in three different columns. 
## We stitch it together to make a column containing all x-coordinates 
## And another column containing all y-coordinates
x = np.concatenate([df['[NAD+free]_(M)'], df['[NAD+free]_(M)'], df['[NAD+free]_(M)']])
y = np.concatenate([df['nbar1'], df['nbar2'], df['nbar3']])

## Your task: Make initial guesses for the three parameters
## The order is that of the function 
## So N, K_D and h.
initial_guess = [1, 1, 1]

## Your task: Make the fit
## Note: The bounds argument has been added to have the function 
## only explore positive sets of parameters. 
fitted_parameters, trash = curve_fit(n_bar, x, y, initial_guess, bounds=(0, np.inf))

# Print the parameters
N_fit, K_D_fit, h_fit = fitted_parameters
print('N_fit', N_fit)
print('K_D_fit', K_D_fit)
print('h_fit', h_fit)
```

Do the fitted parameters support your intuitive reading of the type of cooperativity?

::: {.callout-note}

In the data sets used, repeated experiments were given as a three seperate columns, which 
is a quite natural way of recording data during an experiment. However, it is not 
an appropriate format for regression, where we want all the data-points in a single 
column. In this exercise we did a bit of *data wrangling* to make the data appropriate 
for what we want to do with it - in this case by creating a new joint column containing 
all the data by using the `np.concatenate` function.

:::
