## Determination of reaction orders.

```{python}
#| code-fold: true
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
pd.set_option('display.max_rows', 6)
```

#### (a) Load the dataset

Load the dataset `deter-reacti-orders.xlsx` using the widget below

```{python}
#| eval: false
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('reaction_order_week48') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (b) SI units. 

Add two new columns with the concentrations given in M. 

```{python}
#| exercise: true
#| eval: false
# Make the new columns in this cell. 


display(df)
```

```{python}
#| solution: true
df['[A1]_(M)'] = df['[A1]_(uM)'] * 10**(-6)
df['[A2]_(M)'] = df['[A2]_(uM)'] * 10**(-6)
display(df)
```

#### (c) Plotting 

For each reactant make a plot of 

- $t$ vs. $[\text{A}]$

::: {.callout-note}

We will be adding more elements to the plot in the following parts of the exercise, therefore 
we will wrap the code for plotting in a function such that it can be easily reused. 

:::

The cell below defines the function for plotting, add the missing code in places 
with `...`. 

```{python}
#| exercise: 
#| eval: false
def plot_dataframe(ax, df):
    # Extract from dataframe
    t = df['Time_(s)']
    A1 = df['[A1]_(M)']
    A2 = df['[A2]_(M)']

    ax.plot(t, A1, 'o', label='[A1]')
    ... # Your code here to plot A2

    for ax in axes:
        ax.set_xlabel('t [s]')
        ax.legend()
```

```{python}
#| solution: true
def plot_dataframe(ax, df):
    # Extract from dataframe
    t = df['Time_(s)']
    A1 = df['[A1]_(M)']
    A2 = df['[A2]_(M)']

    # First subfigure: t vs [A]
    ax.plot(t, A1, 'o', label='[A1]')
    ax.plot(t, A2, 'o', label='[A2]')
    ax.set_xlabel('t [s]')
    ax.legend()
```

Once we've written the plotting function we can make the plot as done in the cell 
below. 

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots(1, 1, figsize=(6, 4))

plot_dataframe(ax, df)
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots(1, 1, figsize=(6, 4))

plot_dataframe(ax, df)
```

#### (d) Determining reaction orders

Now we want to determine the reaction orders by making fits to the data under 
the assumption of different integrated rate laws. 

In the cell below finish the code to define functions for the integrated rate laws of 
zeroth, first and second order.

```{python}
#| exercise: true
#| eval: false
def zeroth_order(t, k, A0):
    result = ...
    return result

def first_order(t, k, A0):
    result = ...
    return result

def second_order(t, k, A0):
    result = ...
    return result

rate_laws = {0: zeroth_order, 1: first_order, 2:second_order}
```

```{python}
#| solution: true
def zeroth_order(t, k, A0):
    return A0 - k*t

def first_order(t, k, A0):
    return A0 * np.exp(-k*t)

def second_order(t, k, A0):
    return A0 / (1 + 2*k*t*A0)

rate_laws = {0: zeroth_order, 1: first_order, 2:second_order}
```

We can then use these to make fits, here it is helpful to define a small function to help us with that. 

```{python}
from scipy.optimize import curve_fit

def make_fit(x_data, y_data, x_eval, A0, order):
    # Don't worry about this line for now. 
    # It just picks the correct function for the given order and sets A0.
    func = lambda t, k: rate_laws[order](t, k, A0)

    # Make fit
    popt, pcov = curve_fit(func, x_data, y_data)

    # Evaluate fit
    k = popt[0]
    y_fit = func(x_eval, k)
    return k, y_fit
```

Next we will define the known constants and extract a few things from the `DataFrame`.
In the cell below put the initial concentrations in M.

```{python}
#| exercise: true
#| eval: false
A1_0 = ... # Set the initial concentration [A1]_0
A2_0 = ... # Set the initial concentration [A2]_0

# Extract data
t = df['Time_(s)']
A1 = df['[A1]_(M)']
A2 = df['[A2]_(M)']
orders = [0, 1, 2]
t_eval = np.linspace(0, t.max()*1.1)
```


```{python}
#| solution: true
# Set the initial concentrations:
A1_0 = 2 * 10**(-6)
A2_0 = 4.5 * 10**(-6)

# Extract data
t = df['Time_(s)']
A1 = df['[A1]_(M)']
A2 = df['[A2]_(M)']
orders = [0, 1, 2]
t_eval = np.linspace(0, t.max()*1.1)
```

Now we can make and plot the fits

```{python}
#| exercise: true
#| eval: false
fig, axes = plt.subplots(1, 3, figsize=(8, 4), sharey=True, layout='constrained')

axes[0].set_ylabel('Concentration (M)')

for ax in axes:
    plot_dataframe(ax, df)

for ax, order in zip(axes, orders):
    k1, y_fit = make_fit(t, A1, t_eval, A1_0, order)
    ax.plot(t_eval, y_fit, color='C2', label=rf'k = {k1:.2e}')

    k2, y_fit = make_fit(t, A2, t_eval, A2_0, order)
    ax.plot(t_eval, y_fit, color='C3', label=rf'k = {k2:.2e}')
    ax.legend()
    ax.set_title(f'Reaction order: {order}')
```

```{python}
#| solution: true
fig, axes = plt.subplots(1, 3, figsize=(8, 4), sharey=True, layout='constrained')

axes[0].set_ylabel('Concentration (M)')

for ax in axes:
    plot_dataframe(ax, df)

for ax, order in zip(axes, orders):
    k1, y_fit = make_fit(t, A1, t_eval, A1_0, order)
    ax.plot(t_eval, y_fit, color='C2', label=rf'k = {k1:.2e}')

    k2, y_fit = make_fit(t, A2, t_eval, A2_0, order)
    ax.plot(t_eval, y_fit, color='C3', label=rf'k = {k2:.2e}')
    ax.legend()
    ax.set_title(f'Reaction order: {order}')
```

Based on this plot; 

- What do you believe is the reaction order for [A1]?
- What is the unit of the rate constant for [A1]? 
- What do you believe is the reaction order for [A2]?
- What is the unit of the rate constant for [A2]? 

::: {.callout-note}

The cell above used a `for`-loop. These are a powerful way of performing the same 
operation with different inputs, you will learn more about them later on.

::: 

#### (e) Residuals 

By inspecting the plot we can make a qualitative judgement of the reaction orders. 
To get a more quantitative results we can look at the residuals, recall they are defined as 

$$
r_i = y_i - f(x_i | \theta)
$$

We can calculate these in much the same way we calculate the fits, except we don't 
evaluate the fit at a new set of points but at the observations $x_i$.

```{python}
#| exercise: true
#| eval: false
def calculate_residuals(x_data, y_data, A0, order):
    # Don't worry about this line for now. 
    # It just picks the correct function for the given order and sets A0.
    func = lambda t, k: rate_laws[order](t, k, A0)

    # Make fit
    popt, pcov = curve_fit(func, x_data, y_data)


    # Evaluate fit
    k = popt[0]
    y_fit = ... # Calculate the fit at the x_data using `func`
    residuals = ... # Calculate the residuals.
    return residuals
```

```{python}
#| solution: true
def calculate_residuals(x_data, y_data, A0, order):
    # Don't worry about this line for now. 
    # It just picks the correct function for the given order and sets A0.
    func = lambda t, k: rate_laws[order](t, k, A0)

    # Make fit
    popt, pcov = curve_fit(func, x_data, y_data)

    # Evaluate fit
    k = popt[0]
    y_fit = func(x_data, k)
    residuals = y_data - y_fit
    return residuals
```

We can then plot the residuals, here with the time on the x-axis and the residuals on the y-axis.

```{python}
#| exercise: true
#| eval: false
fig, axes = plt.subplots(2, 3, figsize=(8, 4), sharey=True, layout='constrained', sharex=True)

axes[0, 0].set_ylabel('Reaction 1: Residuals')
axes[1, 0].set_ylabel('Reaction 2: Residuals')

for ax_col, order in zip(axes.T, orders):
    
    residuals = calculate_residuals(t, A1, A1_0, order)
    ax_col[0].plot(t, residuals, 'o', color='C0')
    ax_col[0].axhline(0, color='black', linestyle='--')

    ax_col[0].set_title(f'Reaction order: {order}')

    residuals = calculate_residuals(t, A2, A2_0, order)
    ax_col[1].plot(t, residuals, 'o', color='C1')
    ax_col[1].axhline(0, color='black', linestyle='--')

```

```{python}
#| solution: true
fig, axes = plt.subplots(2, 3, figsize=(8, 4), sharey=True, layout='constrained', sharex=True)

axes[0, 0].set_ylabel('Reaction 1: Residuals')
axes[1, 0].set_ylabel('Reaction 2: Residuals')

for ax_col, order in zip(axes.T, orders):
    
    residuals = calculate_residuals(t, A1, A1_0, order)
    ax_col[0].plot(t, residuals, 'o', color='C0')
    ax_col[0].axhline(0, color='black', linestyle='--')

    ax_col[0].set_title(f'Reaction order: {order}')

    residuals = calculate_residuals(t, A2, A2_0, order)
    ax_col[1].plot(t, residuals, 'o', color='C1')
    ax_col[1].axhline(0, color='black', linestyle='--')

```

Does this support your conclusions about the reaction order from (d)?
