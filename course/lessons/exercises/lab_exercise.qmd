## Lab Exercise Analysis: Michaelis Menten

```{python}
#| code-fold: true
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display
```

In the "Introduction to the Molecules of Life" course, you performed an experiment 
where you measured absorption for different substrate concentrations as a function of 
time. The experiment was done with p-nitrophenylphosphate as the substrate, which turns 
into p-nitrophenol when the enzyme (alkaline phosphatase) acts on it.

If you do not have data, or you find that your data set is not of sufficient quality, you can use the following `kinetics_data.xlsx`.

Load your dataset using the widget below

```{python}
#| eval: false
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('kinetics_LÃ˜') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (a) Units

The measured absorbances are unitless, they are the log of the ratio between the incoming light intensity and the transmitted light intensity. We would like to work with concentrations instead, so we need to convert the absorbance to concentration. The conversion is done using Lambert-Beer's law. 

The extinction coefficient of the product p-nitrophenol is $\varepsilon = 18000 \, \text{M}^{-1} \text{cm}^{-1}$ at $405 \ \text{nm}$ and the path length of the cuvette is $l = 1\, \text{cm}$. We will construct a new `DataFrame` with concentrations

We will start by defining a function `lambert_beers` to calculate the concentrations

```{python}
#| exercise: true
#| eval: false
def lambert_beers(absorbance):
    ## Your task: Finish the implementation of LBs-law to calculate concentrations.    
    L = ... # Units: cm
    ext_coeff = ... # Units: 1 / (M cm)
    conc = ... # Units: M
    return conc
```

```{python}
#| solution: true
def lambert_beers(absorbance):
    ## Your task: Finish the implementation of LBs-law to calculate concentrations.
    L = 1 # cm
    ext_coeff = 18000 # 1 / (M cm)
    conc = absorbance / (L * ext_coeff) # M 
    return conc
```

The next cell makes a new `DataFrame` by applying the lambert_beers function to every column in the original

```{python}
#| exercise: true
#| eval: false
data = {
    'time': df['time'],
    'S_0.8_mM': lambert_beers(df['0.8']),
    'S_0.4_mM': lambert_beers(df['0.4']),
    'S_0.2_mM': lambert_beers(df['0.2']),
    'S_0.12_mM': lambert_beers(df['0.12']),
    'S_0.05_mM': lambert_beers(df['0.05']),
    'S_0.02_mM': lambert_beers(df['0.02']),
    'S_0.01_mM': lambert_beers(df['0.01']),
    'S_0.003_mM': lambert_beers(df['0.003']),
}

df = pd.DataFrame(data)
display(df)
```

```{python}
#| solution: true
data = {
    'time': df['time'],
    'S_0.8_mM': lambert_beers(df['0.8']),
    'S_0.4_mM': lambert_beers(df['0.4']),
    'S_0.2_mM': lambert_beers(df['0.2']),
    'S_0.12_mM': lambert_beers(df['0.12']),
    'S_0.05_mM': lambert_beers(df['0.05']),
    'S_0.02_mM': lambert_beers(df['0.02']),
    'S_0.01_mM': lambert_beers(df['0.01']),
    'S_0.003_mM': lambert_beers(df['0.003']),
}

df = pd.DataFrame(data)
display(df)
```


#### (b) Plot

Now let's plot the data. Plot each column separately as a function of time.

```{python}
#| fig-align: center
#| exercise: true
#| eval: false
fig, ax = plt.subplots()

# Your task: Plot concentration vs. time for each column of the dataset, 
# So 8 lines of code total.
...

## Sets the x and y axis labels.
ax.set_xlabel('Time [s]')
ax.set_ylabel('Concentration [M]')
ax.legend()
plt.show()
```

```{python}
#| fig-align: center
#| solution: true
fig, ax = plt.subplots()

# Your task: Plot concentration vs. time for each column of the dataset, 
# So 8 lines of code total.
ax.plot(df['time'], df['S_0.8_mM'], '-o', label='S_0.8_mM')
ax.plot(df['time'], df['S_0.4_mM'], '-o', label='S_0.4_mM')
ax.plot(df['time'], df['S_0.2_mM'], '-o', label='S_0.2_mM')
ax.plot(df['time'], df['S_0.12_mM'], '-o', label='S_0.12_mM')
ax.plot(df['time'], df['S_0.05_mM'], '-o', label='S_0.05_mM')
ax.plot(df['time'], df['S_0.02_mM'], '-o', label='S_0.02_mM')
ax.plot(df['time'], df['S_0.01_mM'], '-o', label='S_0.01_mM')
ax.plot(df['time'], df['S_0.003_mM'], '-o', label='S_0.003_mM')

ax.set_xlabel('Time [s]')
ax.set_ylabel('Concentration [M]')
ax.legend()
plt.show()
```

```{python}
#| solution: true
#| output: asis
#| echo: false
answer=r"""
::: {.callout-important}

## Alternative solution: for-loop

An alternative solution is using a for-loop, this is beyond the scope 
of the course and you will not get exam questions regarding this. 

However it is more flexible than writing code for every column - the same code  
could be used datasets with hundreds or thousands of columns. 

````python
fig, ax = plt.subplots()

for column_name in df.keys(): # This loops over each column name of the dataframe.
    if column_name != 'time': # Means "if column_name is not equal to 'time'".
        # This only happens when the above condition is met.
        ax.plot(df['time'], df[column_name], '-o', label=column_name)

ax.set_xlabel('Time [s]')
ax.set_ylabel('Concentration [M]')
ax.legend()
plt.show()
````

:::
"""
print(answer)
```

#### (c) Finding the slopes

In order to apply the Michaelis Menten equation we need the slopes of these curves as that is the reaction velocity $V_0$, luckily we have learned how to make fits! So we make a fit to the linear function to determine the slope $a$ in,
$$
y(x) = a x + b
$$
As always, start by writing the function

```{python}
#| solution: true
def linear_function(x, a, b):
    ## Your task: Implement the linear function
    result = ...
    return result
```

```{python}
#| solution: true
def linear_function(x, a, b):
    ## Your task: Implement the linear function
    result = a * x + b
    return result
```

Now we want to find the slope for each column, to help with that we will introduce a 
function that takes the time column and one of the concentration columns and returns the slope

```{python}
#| exercise: true
#| eval: false
def find_slope(time_data, abs_data):
    ## This selects the times and absorbances that have been measured (not NaN)
    ## Don't worry about this - this is just to help you with this exercise.
    indices = np.where(~abs_data.isna())[0]
    time_data = time_data[indices]
    abs_data = abs_data[indices]

    # Find the slope and the intercept using curve_fit and return the slope    
    fitted_parameters, trash = ...
    slope = fitted_parameters[0]

    return slope
```

```{python}
#| solution: true
def find_slope(time_data, abs_data):

    ## This selects the times and absorbances that have been measured (not NaN)
    ## Don't worry about this - this is just to help you with this exercise.
    indices = np.where(~abs_data.isna())[0]
    time_data = time_data[indices]
    abs_data = abs_data[indices]

    ## Find the slope and the intercept using curve_fit and return the slope
    fitted_parameters, trash = curve_fit(linear_function, time_data, abs_data)
    slope = fitted_parameters[0]
    return slope
```

Now we want to use this for each set of measurements at different substrate concentrations. 

```{python}
#| exercise: true
#| eval: true

## Your task: Find the slopes for every substrate concentration.
slope_08 = ...
slope_04 = ...
slope_02 = ...
slope_012 = ...
slope_005 = ...
slope_002 = ...
slope_001 = ...
slope_0003 = ...

## This gathers the slopes and makes an array with the substrate concentrations.
substrate_concentrations = np.array([0.8, 0.4, 0.2, 0.12, 0.05, 0.02, 0.01, 0.003]) * 10**(-3) # Converted from mM to M.
slopes = np.array([slope_08, slope_04, slope_02, slope_012, slope_005, slope_002, slope_001, slope_0003])
```

```{python}
#| solution: true

## Your task: Find the slopes for every substrate concentration.
slope_08 = find_slope(df['time'], df['S_0.8_mM'])
slope_04 = find_slope(df['time'], df['S_0.4_mM'])
slope_02 = find_slope(df['time'], df['S_0.2_mM'])
slope_012 = find_slope(df['time'], df['S_0.12_mM'])
slope_005 = find_slope(df['time'], df['S_0.05_mM'])
slope_002 = find_slope(df['time'], df['S_0.02_mM'])
slope_001 = find_slope(df['time'], df['S_0.01_mM'])
slope_0003 = find_slope(df['time'], df['S_0.003_mM'])

## This gathers the slopes and makes an array with the substrate concentrations.
substrate_concentrations = np.array([0.8, 0.4, 0.2, 0.12, 0.05, 0.02, 0.01, 0.003]) * 10**(-3)
slopes = np.array([slope_08, slope_04, slope_02, slope_012, slope_005, slope_002, slope_001, slope_0003])
```

Now make a plot of the slopes versus the substrate concentrations using the two arrays 
`substrate_concentrations` and `slopes`.

```{python}
#| exercise: true
#| eval: false
fig, ax = plt.subplots() 

## Your task plot the slopes vs. substrate concentration.
...

## Sets x and y axis labels. 
ax.set_xlabel('Substrate concentration')
ax.set_ylabel('Slope')
plt.show()
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots() 

## Your task plot the slopes vs. substrate concentration.
ax.plot(substrate_concentrations, slopes, 'o')

## Sets x and y axis labels. 
ax.set_xlabel('Substrate concentration')
ax.set_ylabel('Slope')
plt.show()
```

```{python}
#| exercise: true
#| eval: false

## Your task: Estimate K_M and V_max from the plot.
K_M_estimate = ...
V_max_estimate = ...
```

```{python}
#| solution: true

## Your task: Estimate K_M and V_max from the plot.
K_M_estimate = 0.00001
V_max_estimate = 8 * 10**(-8)
```


#### (d) Michaelis Menten

Now that we have the slopes we can fit to the Michaelis Menten equation, again we 
need to implement the equation

```{python}
#| exercise: true
#| eval: false
def michaelis_menten(S, K_M, V_max):
    ## Your task: Implement the Michaelis-Menten model.
    result = ...
    return result
```

```{python}
#| solution: true
def michaelis_menten(S, K_M, V_max):
    ## Your task: Implement the Michaelis-Menten model.
    result = (V_max * S) / (K_M + S)
    return result
```

Then fit to the slopes we extracted to the Michealis-Menten equation

```{python}
#| exercise: true
#| eval: false

## This is your estimates as the initial guess.
initial_guess = [K_M_estimate, V_max_estimate]

## Your task: Make a fit to the Michaelis-Menten equation & extract K_M and V_max.
fitted_parameters, trash = ...
K_M_fit, V_max_fit = ...

print(K_M_fit)
print(V_max_fit)
```

```{python}
#| solution: true

## This is your estimates as the initial guess.
initial_guess = [K_M_estimate, V_max_estimate]

## Your task: Make a fit to the Michaelis-Menten equation & extract K_M and V_max.
fitted_parameters, trash = curve_fit(michaelis_menten, substrate_concentrations, slopes, initial_guess)
K_M_fit, V_max_fit = fitted_parameters

print(K_M_fit)
print(V_max_fit)
```

- What is the physical meaning of $K_M$ and how does it relate to binding affinity? 
- What's the meaning of $V_{max}$? Why does the curve saturate? 

#### (e) Plot with fit

```{python}
#| exercise: true
#| eval: false
S_smooth = np.linspace(0, substrate_concentrations.max())
V0_fit = ...
```

```{python}
#| solution: true
S_smooth = np.linspace(substrate_concentrations.min(), substrate_concentrations.max())
V0_fit = michaelis_menten(S_smooth, K_M_fit, V_max_fit)
```

```{python}
#| exercise: true
#| eval: false
#| fig-align: center
fig, ax = plt.subplots() 

## Your task: Plot the data and the fit
...

## These add x and y axis labels.
ax.set_xlabel('Substrate concentration (M)')
ax.set_ylabel('$V_0$ (M/s)')
plt.show()
```

```{python}
#| solution: true
#| fig-align: center
fig, ax = plt.subplots() 

## Your task: Plot the data and the fit
ax.plot(substrate_concentrations, slopes, 'o', label='Data')
ax.plot(S_smooth, V0_fit, label='Fit')

## These add x and y axis labels.
ax.set_xlabel('Substrate concentration (M)')
ax.set_ylabel('$V_0$ (M/s)')
plt.show()
```

#### (f) Turnover number 

Given that the enzyme concentration was $3.33 \frac{\text{mg}}{\text{L}}$ and the molecular weight 
of the enzyme (alkaline phosphatase) is 496.6 $\frac{\text{g}}{\text{mol}}$, calculate the turnover number $k_{cat}$.

Start by converting the enzyme concentration to molar units and then calculate the turnover number.

```{python}
#| exercise: true
#| eval: false

## Your task: Calculate the enzyme concentration and use that and your fit to 
## calculate kcat.
enzyme_conc = ... 
kcat = ... 

print(kcat)
```


```{python}
#| solution: true

## Your task: Calculate the enzyme concentration and use that and your fit to 
## calculate kcat.
enzyme_conc = (3.33*10**(-3)) / 496.6
kcat = V_max_fit / enzyme_conc
print(kcat)
```

- What is the biochemical meaning of this number? 