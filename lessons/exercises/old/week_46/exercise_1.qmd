---
title: "Extinction coefficient of human myoglobin"
categories: ['calculation', 'functions']
topics: []
datasets: ['titin']
---

## Extinction coefficient of human myoglobin

The protein of human myoglobin is given below

```{python}
sequence = """GLSDGEWQLVLNVWGKVEADIPGHGQEVLIRLFKGHPETLEKFDKFKHLKSEDEMKASEDLKKHGA
TVLTALGGILKKKGHHEAEIKPLAQSHATKHKIPVKYLEFISECIIQVLQSKHPGDFGADAQGAMNKALELFRKDMASNY
KELGFQG"""
```

We want to calculate the *extinction coefficient* of this protein, we have seen that 
this can be calculated using the formula

$$
\epsilon(280 \mathrm{nm}) = N_{Trp} \epsilon_{Trp} + N_{Tyr} \epsilon_{Tyr} + N_{Cys} \epsilon_{Cys} 
$$ {#eq-extinction}

Where $N_{Trp}$ is the number of Tryptophan in the protein (and likewise for the other two terms), and the three constants $A$, $B$ and $C$ are given as 

$$
\begin{align}
\epsilon_{Trp} &= 5500 \ \mathrm{M^{−1} cm^{−1}} \\
\epsilon_{Tyr} &= 1490 \ \mathrm{M^{−1} cm^{−1}} \\
\epsilon_{Cys} &= 125 \ \mathrm{M^{−1} cm^{−1}}
\end{align}
$$

In order to calculate the formula we need to know the count of the relevant residues, 
we can use Python to get that - for example we can count the number of Tryptophan like so; 
```{python}
N_trp = sequence.count("W")
```

#### (a) Determine the number of residues

In the cell below find the number of residues

```{python}
#| solution: true
N_tyr = sequence.count("Y")
N_cys = sequence.count("C")
```

```{python}
#| exercise: true
#| eval: false
N_tyr = ... # Your code here
... # Your code here for the N_cys.
```

You can check what Python has stored each variable by using `print`

```{python}
print(N_trp)
print(f"{N_tyr = }") # This is just a way of make a string that looks nice.
print(f"{N_cys = }")
```

#### (b) Calculate the extinction coefficient 

Use equation (@eq-extinction) to calculate the extinction coefficient of human myoglobin.

```{python}
eps_trp = 5500
eps_tyr = 1490
eps_cys = 125
```

```{python}
#| exercise: true
#| eval: false
epsilon = ... # Erstat ... med din kode.
print(epsilon)
```

```{python}
#| solution: true
epsilon = eps_trp * N_trp + eps_tyr * N_tyr + eps_cys*N_cys
print(epsilon)
```
What are the units of this value? 

#### (c) Compare residue count to ProtParam 

ProtParam is an online tool that calculates various physical and chemical
parameters from a given protein sequence and is used worldwide in research laboratories.

![Protpram tool input page.](https://raw.githubusercontent.com/au-mbg/fysisk-biokemi/refs/heads/main/lessons/figures/week_46/protpram_input.png){.lightbox}

Go to ProtPram at this link: [https://web.expasy.org/protparam/](https://web.expasy.org/protparam/) and paste the 
sequence and click **Compute Parameters**. You should then see the calculated parameters, similar 
to in the image below 

![Protpram tool calculated properties.](https://raw.githubusercontent.com/au-mbg/fysisk-biokemi/refs/heads/main/lessons/figures/week_46/protpram_output.png){.lightbox}

On the output page you will see the number of residues, does that match your calculation? 

#### (d) Calculate the absorbance

Using the extinction coefficient and the molecular weight given by ProtParam, calculate the absorbance at 280 nm of a myoglobin solution at a concentration of 1 mg/mL in a cuvette with a light path of 1 cm.

```{python}
#| solution: true
molecular_weight = 17052.61 
path_length = 1 # cm 
concentration = 1 # mg/mL
```

```{python}
#| exercise: true
#| eval: false
molecular_weight = ... # Find the value on ProtPram (It has units of g/mol)
path_length = ... # Set the value of the path length
concentration = ... # Set the value of the concentraiton.
```

Remember to convert the concentration to $\mathrm{mol/L}$.

```{python}
#| exercise: true
#| eval: false
A280 = ...
print(A280)
```

```{python}
#| solution: true
A280 = concentration / molecular_weight * path_length * epsilon
print(A280)
```

This value is what is known as the A280(0.1%) of a protein, i.e. the absorbance of a given protein at a concentration of 0.1% weight/volume (= 1 g/L = 1 mg/mL). 

#### (e) Tintin 

We have now calculated the extinction coefficient of a protein, now we will make our 
code more reusable so that it can be applied to other proteins easily. 

::: {.callout-note}

A function in Python is a set of instructions, like a recipe, that can be defined 
and reused multiple times. The syntax is like this

```python
def my_function(input_1, input_2): # <1>
    # Some operation 
    some_internal_variable = input_1 + input_2 # <2>
    ... 
    return something_weve_calculated # <3>
```

1. The `def` command is used to define the functions name, here `my_function`, and state its inputs, e.g. the name and ingredients of a recipe.
2. The body of the function defines what it does, the body can have any number of lines of code. Similar to the instructions of a recipe. 
3. Finally, the function can `return` something, like the final product of a recipe. 

Note that the function is not executed by doing this, like how a cake isn't baked by writing down the recipe, in order actually use the function it needs to be *called*

```python
output = my_function(1, 2)
```

This is also how we have already used other functions like `print`.

::: 

The way of doing so is by defining a function that does the necessary operations for a given sequence. 
In this way the code can be reused for any sequence. 

Finish implementing the body of the function below, note that you have already written all the required 
code - you just need to copy it into the function.

```{python}
#| exercise: true
#| eval: false
def extinction_coefficient(sequence):

    # Start by counting
    ...

    # Define the residue extinction coeffiecients
    eps_trp = 5500
    eps_tyr = 1490
    eps_cys = 125

    # Calculate 
    epsilon = ...

    return epsilon
```

```{python}
#| solution: true
def extinction_coefficient(sequence):

    # Start by counting: 
    N_trp = sequence.count("W")
    N_tyr = sequence.count("Y")
    N_cys = sequence.count("C")

    # Define the residue extinction coeffiecients
    eps_trp = 5500
    eps_tyr = 1490
    eps_cys = 125

    # Calculate 
    epsilon = eps_trp * N_trp + eps_tyr * N_tyr + eps_cys*N_cys

    return epsilon
```

It's always a good idea to check that functions do what we expect, so we can confirm that 
it gives the same result for human myoglobin as we calculated before 

```{python}
#| exercise: true
#| eval: false
epsilon_func = extinction_coefficient(sequence)
print(f"Epsilon: {epsilon}")
print(f"Epsilon from function: {epsilon_func}")
```

```{python}
#| solution: true
epsilon_func = extinction_coefficient(sequence)
print(f"Epsilon: {epsilon}")
print(f"Epsilon from function: {epsilon_func}")
```

The largest known protein is Titin, the cell below loads the sequence of titin 
and prints a few bits of information about it.

```{python}
#| exercise: true
#| eval: false
from fysisk_biokemi.datasets import load_dataset
titin_sequence = load_dataset('titin')

print(f'Titin number of residues: {len(titin_sequence)}')
print('First 100 residues')
print(titin_sequence[0:100])
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
titin_sequence = load_dataset('titin')

print(f'Titin number of residues: {len(titin_sequence)}')
print('First 100 residues')
print(titin_sequence[0:100])
```

Use your function to calculate the extinction coefficient of titin.

```{python}
#| exercise: true
#| eval: false
titin_eps = ... # Your code here. 
print(titin_eps)
```

```{python}
#| solution: true
titin_eps = extinction_coefficient(titin_sequence)
print(titin_eps)
```

---

::: {.callout-tip}

You don't need to understand the code below, it's just ment to illustrate that knowing 
some Python will allow you to explore the topics that interest you in more detail.

:::

In general Python is very powerful at letting us explore properties of sequences, 
for example the cell below calculates number of residues between each Tryptophan in 
the Titin sequence and plot the distribution.
```{python}
import numpy as np
import matplotlib.pyplot as plt

def get_distance(sequence, letter):
    W_index = np.argwhere(np.array([l for l in sequence]) == letter)
    count = len(W_index)
    distance = (W_index - np.roll(W_index, 1))[1:]
    return distance, count

letters = ['W', 'Y', 'C']

fig, axes = plt.subplots(1, 3, figsize=(3*3, 3), sharey=True)
axes = axes.flatten()

for ax, letter in zip(axes, letters):
    distance, count = get_distance(titin_sequence, letter)
    ax.hist(distance, bins=np.arange(0, 500, 25), 
        edgecolor='black', alpha=0.75, density=True)
    ax.set_xlabel('Distance [Number of residues]')
    info = f'Residue: {letter} \nCount: {count} \nMean distance: {np.mean(distance):.1f}'
    ax.text(0.975, 0.975, info, transform=ax.transAxes, ha='right', va='top')
```
