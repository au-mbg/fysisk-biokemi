---
title: Week 47
engine: jupyter
categories: ['UVis']
format-links:
    - text: "Open in Google Colab"
      href: "https://colab.research.google.com/github/au-mbg/fysisk-biokemi/blob/built-notebooks/built_notebooks/student/week_47.ipynb"
      icon: box-arrow-up-right
---

``` {python}
#| eval: false
#| code-fold: true
try:
    import fysisk_biokemi
    print("Already installed")
except ImportError:
    %pip install -q "fysisk_biokemi[colab] @ git+https://github.com/au-mbg/fysisk-biokemi.git"
```

---

## The fluorescent protein "mCherry".

The spectra of many fluorescent proteins can be found at the website: [www.fpbase.org](https://www.fpbase.org/). Go to FPbase and search for “mCherry”. 

#### (a) Find parameters. 

Find the following parameters for the protein

- Extinction coefficient at absorbance maximum 
- Quantum yield 
- The organism from which it was originally isolated
- Molecular weight

Save them to seperate variables in the cell below.

```{python}
#| solution: true
QY = 0.22
EC = 72000 # [1/(M cm)]
organism = "Discosoma sp."
m_w = 26.7 * 10**3 # From fpbase
```

```{python}
#| exercise: true
#| eval: false
... # Your answers here. 
```

#### (b)	Adorbance

What is the absorbance of a 1 µM solution of mCherry at its absorption maximum?

```{python}
#| exercise: true
#| eval: false
c = ... # Put the concentration in Molar
l = ... # Path length in cm
A_max = ... # Calculate the adsorbance.
print(f"{A_max = :3.3f}")
```

```{python}
#| solution: true
c = 1 * 10**(-6) # [M]
l = 1 # [cm]
A_max = EC * c * l
print(f"{A_max = :3.3f}")
```

#### (c)	Extinction coefficient from sequence. 

The sequence of the protein is also given. From this determine the extinction coefficient at 280 nm.

Start by taking the sequence from the website and assigning it to the variable `sequence` in the cell below. 

```{python}
#| exercise: true
#| eval: false
sequence = ... # Your code here
```
```{python}
#| solution: true
sequence="""MVSKGEEDNM AIIKEFMRFK VHMEGSVNGH EFEIEGEGEG RPYEGTQTAK LKVTKGGPLP FAWDILSPQF MYGSKAYVKH PADIPDYLKL SFPEGFKWER VMNFEDGGVV TVTQDSSLQD GEFIYKVKLR GTNFPSDGPV MQKKTMGWEA SSERMYPEDG ALKGEIKQRL KLKDGGHYDA EVKTTYKAKK PVQLPGAYNV NIKLDITSHN EDYTIVEQYE RAEGRHSTGG MDELYK"""
```

Now use the sequence to calculate the extinction coefficient

```{python}
#| exercise: true

# This is "dictionary" with the extinction coefficients of the relevant 
# amino acid residues. Dictionaries are indexed with 'keys', so you can retrieve
# the value for W as: ext_residue["W"].
ext_residue = {"W": 5500, "Y": 1490, "C": 125}

# Write code to calculate the extinction coefficent
...
```

```{python}
#| solution: true

# This is 'dictionary' with the extinction coefficients of the relevant 
# amino acid residues. Dictionaries are indexed with 'keys', so you can retrieve
# the value for W as: ext_residue["W"].
ext_residue = {"W": 5500, "Y": 1490, "C": 125}

# Count the number of active residues
N_trp = sequence.count("W")
N_tyr = sequence.count("Y")
N_cys = sequence.count("C")

# Calculate the extinction coefficient: 
ext_coeff = N_trp * ext_residue["W"] + N_tyr * ext_residue["Y"] + N_cys * ext_residue["C"]

print(f"{ext_coeff = :3.3f}")
```

#### (d)	What is the concentration of a 1 µM solution of mCherry in mg/mL?

```{python}
#| exercise: true
#| eval: false
conc_molar = ... # Put the concentration in units of M. 
conc_mg_mL = ... # Calculate the concentration in uts of mg/mL.
print(f"{conc_mg_mL = }")
```

```{python}
#| solution: true
conc_molar = 1 * 10**(-6) # From 1 [uM].
conc_mg_mL = conc_molar * m_w 
print(f"{conc_mg_mL = }")
```

---

The excitation and emission spectra can be downloaded as a csv-file by clicking the download icon as highlighted below

![Download spectra](https://raw.githubusercontent.com/au-mbg/fysisk-biokemi/refs/heads/main/lessons/figures/week_47/download_spectra.png){.lightbox}

---

#### (e)    Load the dataset

Use the widget below to load the dataset as a `DataFrame`

```{python}
#| eval: false
from fysisk_biokemi.widgets import DataUploader
from IPython.display import display 
uploader = DataUploader()
uploader.display()
```

Run the next cell **after** uploading the file

```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from IPython.display import display 
from fysisk_biokemi.datasets import load_dataset
df = load_dataset('mCherry') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (f)	Plot spectra

Make your own plot showing the excitation and emission spectra of “mCherry” using the above data.

::: {.callout-tip}

You don't have to worry about the `NaN` values in the dataset when plotting, matplotlib just skips 
plotting that line segment.

::::

```{python}
#| exercise: true
#| eval: false
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(9, 4))
ax.plot(..., ..., label='Excitation') # Replace ... with your code
... # Replace ... with your code plotting the emission spectrum.
ax.legend()
ax.set_xlabel('Wavelength')
ax.set_ylabel('Extinction & Emission')
plt.show()
```

```{python}
#| solution: true
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(9, 4))
ax.plot(df['wavelength'], df['mCherry ex'], label='Excitation')
ax.plot(df['wavelength'], df['mCherry em'], label='Emission')
ax.legend()
ax.set_xlabel('Wavelength')
ax.set_ylabel('Extinction & Emission')
plt.show()
```

#### (g)	Stokes shift

What is the Stokes shift of mCherry?

::: {.callout-tip}

If you have two arrays `A` and `B` you can find the entry in `A` corresponding to the largest 
value in `B` like this 

```python
A_at_B_max = A[np.argmax(B)]
```

::: 

```{python}
#| exercise: true
#| eval: false
import numpy as np
lambda_ex = df['wavelength'][np.argmax(df['mCherry ex'])]
lambda_em = df['wavelength'][np.argmax(df['mCherry em'])]
stokes_shift = lambda_em - lambda_ex

print(f"{lambda_ex = :d}")
print(f"{lambda_em = :d}")
print(f"{stokes_shift = :d}")
```

```{python}
#| solution: true
import numpy as np
lambda_ex = df['wavelength'][np.argmax(df['mCherry ex'])]
lambda_em = df['wavelength'][np.argmax(df['mCherry em'])]
stokes_shift = lambda_em - lambda_ex

print(f"{lambda_ex = :d}")
print(f"{lambda_em = :d}")
print(f"{stokes_shift = :d}")
```

#### (h)	Colors 

What colors are the light that correspond to the excitation and emission maxima respectively?

---

## Proteins in blood plasma.

In this exercise we will learn how Python is excellent for handling datasets with many data points and 
how it can be used to apply the same procedure to all the data points at once.

A researcher wants to determine the concentration of two proteins in blood plasma that is suspected to be involved in development of an autoimmune disease. 500 patients and 500 healthy individuals were included in the study and absorbance measurements of the two purified proteins from all blood plasma samples were measured at 280 nm. The molecular weight and extinction coefficients of the two proteins are given in the table below.

| Protein  | $M_w$ $[\text{kDa}]$    |  $\epsilon$ $[\text{M}^{-1}\text{cm}^{-1}]$ |
| -------- | ------- | ---------- |
| 1        | 130     | 180000     | 
| 2        | 57      | 80000      |

: Properties of the two proteins.

#### (a) Load the dataset

Use the widget to load the dataset as a dataframe from the file **protein_blood_plasma.xlsx**

```{python}
#| eval: false
from IPython.display import display 
from fysisk_biokemi.widgets import DataUploader
uploader = DataUploader()
uploader.display()
```
Run this cell **after** having uploaded the file in the cell above.
```{python}
#| eval: false
df = uploader.get_dataframe()
display(df)
```

```{python}
#| solution: true
from fysisk_biokemi.datasets import load_dataset
from IPython.display import display 
df = load_dataset('protein_blood_plasma') # Load from package for the solution so it doesn't require to interact.
display(df)
```

#### (b) Calculate concentrations

Calculate the molar concentration of the two proteins in all samples, the light path for 
every measurement is 0.1 cm.

Always a good idea to assign known values to variables
```{python}
protein_1_ext_coeff = 180000
protein_2_ext_coeff = 80000
l = 0.1
```

::: {.callout-tip}

You can set new columns in a `DataFrame` by just assigning to it 

```python
df['new_column'] = [1, 2, 3, ..., 42]
```

It can also be set as a computation of a property from another row

```python
df['new_column'] = df['current_column'] / 4
```

::: 

```{python}
#| exercise: true
#| eval: false
df['protein1_healthy_molar_conc'] = ... # Calculate for concentration in healthy for protein 1.
... # Your code that updates the data frame with the 3 other new columns.
display(df)
```

```{python}
#| solution: true
df['protein1_healthy_molar_conc'] = df['A280_protein1_healthy'] / (protein_1_ext_coeff * l)
df['protein1_patient_molar_conc'] = df['A280_protein1_patient'] / (protein_1_ext_coeff * l)
df['protein2_healthy_molar_conc'] = df['A280_protein2_healthy'] / (protein_2_ext_coeff * l)
df['protein2_patient_molar_conc'] = df['A280_protein2_patient'] / (protein_2_ext_coeff * l)
display(df)
```

#### (c). Concentrations in mg/mL

Add another set of four columns containing the concentrations in mg/mL.

```{python}
protein_1_mw = 130 * 10**3
protein_2_mw = 57 * 10**3
```

```{python}
#| exercise: true
#| eval: false
df['protein1_healthy_conc'] = ...
df['protein1_patient_conc'] = ...
df['protein2_healthy_conc'] = ...
df['protein2_patient_conc'] = ...

names = ['protein1_healthy_conc', 'protein1_patient_conc', 'protein2_healthy_conc', 'protein2_patient_conc']
display(df[names])
```

```{python}
#| solution: true
df['protein1_healthy_conc'] = df['protein1_healthy_molar_conc'] * protein_1_mw
df['protein1_patient_conc'] = df['protein1_patient_molar_conc'] * protein_1_mw
df['protein2_healthy_conc'] = df['protein2_healthy_molar_conc'] * protein_2_mw
df['protein2_patient_conc'] = df['protein2_patient_molar_conc'] * protein_2_mw

names = ['protein1_healthy_conc', 'protein1_patient_conc', 'protein2_healthy_conc', 'protein2_patient_conc']
display(df[names])
```

#### (d) Mean concentration

Now that we have the concentrations, calculate the concentration in the four categories. 

::: {.callout-tip}

When displaying the dataframe above we used indexed it with `names` as `df[names]`. 
We can do the same to compute something over just the four rows. 

For example the if we have a `DataFrame` called `example_df`, we can calculate the mean 
over the **rows** as: 

```python
df[names].mean(axis=0)
```

Here `axis=0` means that we apply the operation over the first axis which by convention are the rows. 

::: 

```{python}
#| exercise: true
#| eval: false
mean = ...
display(mean)
```

```{python}
#| solution: true
mean = df[names].mean(axis=0)
display(mean)
```

#### (e) Standard deviation

Calculate the standard deviation 

::: {.callout-tip}

The standard deviation can be calculated using the `.std`-method that works in the same way 
as the `.mean`-method we used above.

:::

```{python}
#| exercise: true
#| eval: false
std = ...
display(std)
```

```{python}
#| solution: true
std = df[names].std(axis=0)
display(std)
```

#### (f) Analyze the results 

Consider the following questions

- By comparing healthy individuals with patients, would you expect that any of the two proteins would be involved in disease development? 
- What additional information does the standard deviation provide besides the average value of the protein concentration?

